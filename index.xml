<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>常用中间件分析</title><link>https://zput.github.io/middleware/</link><description>Recent content on 常用中间件分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 24 Jan 2020 10:33:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/middleware/index.xml" rel="self" type="application/rss+xml"/><item><title>mysql高级总结</title><link>https://zput.github.io/middleware/docs/mysql/MySQL/</link><pubDate>Fri, 24 Jan 2020 10:33:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/MySQL/</guid><description>0.重要的知识点 # MySQL逻辑架构 1.1. 连接层 1.2. 服务层 1.3. 引擎层(存储引擎是基于表的，而不是数据库) 1.4. 存储层
如何修改字符集(查看1.3)
日志 3.1. 查询日志 3.2. 错误日志 3.3. 二进制日志
分析慢SQL的步骤 first:找到是那些sql慢. 4.1. 慢查询的开启，设置阈值(如超过5秒钟的就是慢SQL)并捕获。 second:开始分析这些sql. 4.2. explain + 慢SQL分析。 查询语句写的差。 关联 查询太多join（设计缺陷或者不得已的需求）。 索引失效：索引建了，但是没有用上。 4.3. show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。 4.4. MySQL数据库服务器的参数调优。 SQL执行顺序 select # 5 ----&amp;gt; ... from # 1 ... where # 2 .... group by # 3 ... having # 4 ----&amp;gt; ... order by # 6 ... limit # 7 [offset] join 索引 what: A database index is a data structure that improves the speed of operations in a table</description></item><item><title>写好sql</title><link>https://zput.github.io/middleware/docs/mysql/business_facing/sql/</link><pubDate>Fri, 24 Jan 2020 10:33:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/business_facing/sql/</guid><description>SQL # SQL执行顺序 # select # 5 ----&amp;gt; ... from # 1 ... where # 2 .... group by # 3 ... having # 4 ----&amp;gt; ... order by # 6 ... limit # 7 [offset] 七种JOIN # /* 1 */ SELECT &amp;lt;select_list&amp;gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key; /* 2 */ SELECT &amp;lt;select_list&amp;gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.</description></item><item><title>初始化</title><link>https://zput.github.io/middleware/docs/mysql/init/install/</link><pubDate>Fri, 24 Jan 2020 10:33:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/init/install/</guid><description>MySQL环境 # 环境安装 # # 查看Linux服务器上是否安装过MySQL rpm -qa | grep -i mysql # 查询出所有mysql依赖包 # 1、拉取镜像 docker pull mysql:5.7 # 2、创建实例并启动 docker run -p 3306:3306 --name mysql \ -v /root/mysql/log:/var/log/mysql \ -v /root/mysql/data:/var/lib/mysql \ -v /root/mysql/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=qwer \ -d mysql:5.7 # conf # 配置文件!!! # 4、重启mysql容器 docker restart mysql # 5、进入到mysql容器 docker exec -it mysql /bin/bash # 6、查看修改的配置文件 cat /etc/mysql/my.conf 安装位置 # Docker容器就是一个小型的Linux环境，进入到MySQL容器中。
docker exec -it mysql /bin/bash Linux环境下MySQL的安装目录。</description></item><item><title>索引</title><link>https://zput.github.io/middleware/docs/mysql/business_facing/innodb_index/</link><pubDate>Fri, 24 Jan 2020 10:33:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/business_facing/innodb_index/</guid><description>索引 # 索引简介 # 索引是什么？
A database index is a data structure that improves the speed of operations in a table MySQL官方对索引的定义为：索引（INDEX）是帮助MySQL对表高效操作的数据结构。
从而可以获得索引的本质：索引是排好序的快速查找数据结构。
索引的目的在于提高查询效率，可以类比字典的目录。如果要查mysql这个这个单词，我们肯定要先定位到m字母，然后从上往下找y字母，再找剩下的sql。如果没有索引，那么可能需要a---z，这样全字典扫描，如果我想找Java开头的单词呢？如果我想找Oracle开头的单词呢？？？
重点：索引会影响到MySQL查找(WHERE的查询条件)和排序(ORDER BY)两大功能！
除了数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。
# Linux下查看磁盘空间命令 df -h [root@Ringo ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 16G 23G 41% / devtmpfs 911M 0 911M 0% /dev tmpfs 920M 0 920M 0% /dev/shm tmpfs 920M 480K 920M 1% /run tmpfs 920M 0 920M 0% /sys/fs/cgroup overlay 40G 16G 23G 41% 我们平时所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种数据结构的索引之外，还有哈希索引（Hash Index）等。</description></item><item><title>锁</title><link>https://zput.github.io/middleware/docs/mysql/business_facing/innodb_lock/</link><pubDate>Fri, 24 Jan 2020 10:33:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/business_facing/innodb_lock/</guid><description>表锁(偏读) # 表锁特点：
表锁偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。 环境准备 # # 1、创建表 CREATE TABLE `mylock`( `id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(20) )ENGINE=MYISAM DEFAULT CHARSET=utf8 COMMENT=&amp;#39;测试表锁&amp;#39;; # 2、插入数据 INSERT INTO `mylock`(`name`) VALUES(&amp;#39;ZhangSan&amp;#39;); INSERT INTO `mylock`(`name`) VALUES(&amp;#39;LiSi&amp;#39;); INSERT INTO `mylock`(`name`) VALUES(&amp;#39;WangWu&amp;#39;); INSERT INTO `mylock`(`name`) VALUES(&amp;#39;ZhaoLiu&amp;#39;); 锁表的命令 # 1、查看数据库表锁的命令。
# 查看数据库表锁的命令 SHOW OPEN TABLES; 2、给mylock表上读锁，给book表上写锁。
# 给mylock表上读锁，给book表上写锁 LOCK TABLE `mylock` READ, `book` WRITE; # 查看当前表的状态 mysql&amp;gt; SHOW OPEN TABLES; +--------------------+------------------------------------------------------+--------+-------------+ | Database | Table | In_use | Name_locked | +--------------------+------------------------------------------------------+--------+-------------+ | sql_analysis | book | 1 | 0 | | sql_analysis | mylock | 1 | 0 | +--------------------+------------------------------------------------------+--------+-------------+ 3、释放表锁。</description></item><item><title>mysql总结</title><link>https://zput.github.io/middleware/docs/mysql/mysql2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/mysql2/</guid><description>0.重要的知识点 表空间的格式 页的结构 文件管理页 INODE页 INDEX数据索引页 聚簇和非聚簇 index Row Format what: what: how: 讨论innodb数据结构 log mvcc FQA 0.重要的知识点 # MySQL逻辑架构 1.1. 连接层 1.2. 服务层 1.3. 引擎层(存储引擎是基于表的，而不是数据库) 1.4. 存储层
如何修改字符集(查看1.3)
日志 3.1. 查询日志 3.2. 错误日志 3.3. 二进制日志
分析慢SQL的步骤 first:找到是那些sql慢. 4.1. 慢查询的开启，设置阈值(如超过5秒钟的就是慢SQL)并捕获。 second:开始分析这些sql. 4.2. explain + 慢SQL分析。 查询语句写的差。 关联 查询太多join（设计缺陷或者不得已的需求）。 索引失效：索引建了，但是没有用上。 4.3. show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。 4.4. MySQL数据库服务器的参数调优。 SQL执行顺序 select # 5 ----&amp;gt; ... from # 1 ... where # 2 .... group by # 3 .</description></item><item><title>底层结构</title><link>https://zput.github.io/middleware/docs/mysql/advanced/page_lock_log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/advanced/page_lock_log/</guid><description>索引 # what: A database index is a data structure that improves the speed of operations in a table
索引分类： 单值索引：一个索引只包含单个列，一个表可以有多个单列索引。 唯一索引：索引列的值必须唯一，但是允许空值。 复合索引：一个索引包含多个字段。 why:
索引的优势和劣势 优势： 查找：类似大学图书馆的书目索引，提高数据检索的效率，降低数据库的IO成本。 排序：通过索引対数据进行排序，降低数据排序的成本，降低了CPU的消耗。 劣势： 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。 虽然索引大大提高了查询速度，但是同时会降低表的更新速度，例如对表频繁的进行INSERT、UPDATE和DELETE。因为更新表的时候，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。 索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引。 how:
重点：索引会影响到MySQL查找(WHERE的查询条件)和排序(ORDER BY)两大功能！ 什么时候需要建立索引： 主键:主键自动建立主键索引（唯一 + 非空）。 where/order by: 频繁作为查询条件的字段应该创建索引。 查询中统计或者分组字段（group by也和索引有关）。 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。 查询中与其他表关联的字段，外键关系建立索引。 索引分析 从9.1.单表索引分析&amp;ndash;&amp;gt;范围之后的索引会失效。 从9.2.两表索引分析&amp;mdash;&amp;gt;左连接将索引创建在右表上更合适。 10.1.索引失效的情况: 全值匹配我最爱。 最佳左前缀法则。 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。 索引中范围条件右边的字段会全部失效。 尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少SELECT *。 MySQL在使用!=或者&amp;lt;&amp;gt;的时候无法使用索引会导致全表扫描。 is null、is not null也无法使用索引。 like以通配符开头%abc索引失效会变成全表扫描。 字符串不加单引号索引失效。 少用or，用它来连接时会索引失效。 锁 # what: InnoDB锁: 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：</description></item></channel></rss>