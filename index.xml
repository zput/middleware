<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>常用中间件分析</title><link>https://zput.github.io/middleware/</link><description>Recent content on 常用中间件分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 24 Jan 2020 10:33:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/middleware/index.xml" rel="self" type="application/rss+xml"/><item><title>隔离性-锁</title><link>https://zput.github.io/middleware/docs/mysql/advanced/ACID/isolution/</link><pubDate>Sat, 26 Mar 2016 08:47:11 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/advanced/ACID/isolution/</guid><description>锁原理 # 首先，如果要你实现一把锁，该如何实现呢？就从简单到复杂,慢慢考虑性能等一些因素。
一个变量 一个抢占动作: 抢占失败(比如已经被其他线程抢占了)处理: immediately-retry yield sleep park mix(immediately-retry, yield/sleep/park) 重试 下面是它的伪代码:
var v = 0 func unlock(){ //解锁 v=0 } func lock(){ //加锁 retry: if !CompareAndSet(0, 1){ handleErr() goto retry } } func handleErr(){ // 处理方式有如下几种 // immediately-retry // yield // sleep // park // mix(immediately-retry, yield/sleep/park) } func CompareAndSet(except, newValue int)bool{ //cas操作,如果修改v则返回true } 下面我们来讲讲这几种CAS失败后处理方式。
自旋 # 最容易想到可能是自旋：
func handleErr(){ // 可以使用CPU提供的PAUSE指令来实现「忙等待」，因为可以减少循环等待时的耗电量 return // 直接返回，马上重试// immediately-retry } 这样实现的锁显然有个致命的缺点：耗费cpu资源。没有竞争到锁的线程会一直占用cpu资源进行cas操作，假如一个线程获得锁后要花费10s处理业务逻辑，那另外一个线程就会白白的花费10s的cpu资源。（假设系统中就只有这两个线程的情况）。</description></item><item><title>索引</title><link>https://zput.github.io/middleware/docs/mysql/advanced/innodb_index/</link><pubDate>Sat, 26 Mar 2016 08:47:11 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/advanced/innodb_index/</guid><description>索引的分类 # 从分类入手，从底层索引的物理结构开始讨论构建索引的自己规范：
按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。 按「字段个数」分类：单列索引、联合索引。
索引建立标准 # 从业务：经常where/group by / order by 从物理结构: 字段区分度要大(最好是唯一性) 从物理结构: 非经常变更的字段，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。 自增类型 从业务 # 从物理结构 # // TODO 添加 索引底层页的物理结构 // TODO 添加 联合索引的物理结构
首先创建索引和维护索引要耗费时间:
占用物理空间，数量越多，占用空间越大； B+ 树为了维护索引有序性，都需要进行动态维护。 (聚簇)主键索引最好是自增的 # InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。
如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。
如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。
举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：
(非聚簇)二级索引 # 区分度太小的不适合 # // 区分度太小的也不适合做索引，比如sex字段，它的值一般不超过三个，区分度太小，你就算找到了sex=man的，你还是需要在它剩下的里面查找b,c,这种相当于查找了三分之一个表。还需要回表。
联合索引的顺序要挑选最常用的在最前面 # (a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。 联合索引的最左匹配原则，在遇到范围查询（&amp;gt;、&amp;lt;、between、like 包括like &amp;lsquo;林%&amp;lsquo;这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引。 // 就知道了它对于联合索引的一些问题，比如a,b,c; where b,c的时候就不会进过索引。</description></item><item><title>聚合函数</title><link>https://zput.github.io/middleware/docs/mysql/advanced/function/</link><pubDate>Sat, 26 Mar 2016 08:47:11 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/advanced/function/</guid><description>count函数 # count()是一个函数，他的形参可以是一个字段或表达式; 函数逻辑是统计符合查询条件的记录中，如果使当前字段/表达式不为null的个数。比如select count(1) from tmp_table; 那么就是统计tmp_table表有多少行，因它的每个记录都不会使得表达式1为null。返回是统计结果
count(*)==count(1) &amp;gt; count(聚簇索引) &amp;gt;= count(非聚簇索引) &amp;gt; count(非索引字段) count(*)等同于count(1) # InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.
不需要读取记录中的字段值然后再去判断, 所以server层不需要innodb返回字段
count(聚簇索引) # 有辅助索引时，InnoDB循环遍历的对象就不是聚簇索引，而是辅助索引。
如果有多个辅助索引, 优化器会使用key_len,挑选最小的辅助索引进行扫描。
这是因为相同数量的辅助索引记录可以比聚簇索引记录占用更少的存储空间，所以辅助索引树比聚簇(主键)索引树小，这样遍历辅助索引的 I/O 成本比遍历聚簇(主键)索引的 I/O 成本小，因此「优化器」优先选择的是最小的辅助索引。
count(非聚簇索引) # 使用辅助索引来进行统计</description></item><item><title>写好sql</title><link>https://zput.github.io/middleware/docs/mysql/business_facing/sql/</link><pubDate>Fri, 24 Jan 2020 10:33:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/business_facing/sql/</guid><description>SQL # SQL执行顺序 # select # 5 ----&amp;gt; ... from # 1 ... where # 2 .... group by # 3 ... having # 4 ----&amp;gt; ... order by # 6 ... limit # 7 [offset] 七种JOIN # /* 1 */ SELECT &amp;lt;select_list&amp;gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key; /* 2 */ SELECT &amp;lt;select_list&amp;gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.</description></item><item><title>初始化</title><link>https://zput.github.io/middleware/docs/mysql/init/install/</link><pubDate>Fri, 24 Jan 2020 10:33:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/init/install/</guid><description>MySQL环境 # 环境安装 # # 查看Linux服务器上是否安装过MySQL rpm -qa | grep -i mysql # 查询出所有mysql依赖包 # 1、拉取镜像 docker pull mysql:5.7 # 2、创建实例并启动 docker run -p 3306:3306 --name mysql \ -v /root/mysql/log:/var/log/mysql \ -v /root/mysql/data:/var/lib/mysql \ -v /root/mysql/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=qwer \ -d mysql:5.7 # conf # 配置文件!!! # 4、重启mysql容器 docker restart mysql # 5、进入到mysql容器 docker exec -it mysql /bin/bash # 6、查看修改的配置文件 cat /etc/mysql/my.conf 安装位置 # Docker容器就是一个小型的Linux环境，进入到MySQL容器中。
docker exec -it mysql /bin/bash Linux环境下MySQL的安装目录。</description></item><item><title>索引</title><link>https://zput.github.io/middleware/docs/mysql/business_facing/innodb_index/</link><pubDate>Fri, 24 Jan 2020 10:33:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/business_facing/innodb_index/</guid><description>索引 # 索引简介 # 索引是什么？
A database index is a data structure that improves the speed of operations in a table MySQL官方对索引的定义为：索引（INDEX）是帮助MySQL对表高效操作的数据结构。
从而可以获得索引的本质：索引是排好序的快速查找数据结构。
索引的目的在于提高查询效率，可以类比字典的目录。如果要查mysql这个这个单词，我们肯定要先定位到m字母，然后从上往下找y字母，再找剩下的sql。如果没有索引，那么可能需要a---z，这样全字典扫描，如果我想找Java开头的单词呢？如果我想找Oracle开头的单词呢？？？
重点：索引会影响到MySQL查找(WHERE的查询条件)和排序(ORDER BY)两大功能！
除了数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。
# Linux下查看磁盘空间命令 df -h [root@Ringo ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/vda1 40G 16G 23G 41% / devtmpfs 911M 0 911M 0% /dev tmpfs 920M 0 920M 0% /dev/shm tmpfs 920M 480K 920M 1% /run tmpfs 920M 0 920M 0% /sys/fs/cgroup overlay 40G 16G 23G 41% 我们平时所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种数据结构的索引之外，还有哈希索引（Hash Index）等。</description></item><item><title>锁</title><link>https://zput.github.io/middleware/docs/mysql/business_facing/innodb_lock/</link><pubDate>Fri, 24 Jan 2020 10:33:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/business_facing/innodb_lock/</guid><description>表锁(偏读) # 表锁特点：
表锁偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。 环境准备 # # 1、创建表 CREATE TABLE `mylock`( `id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(20) )ENGINE=MYISAM DEFAULT CHARSET=utf8 COMMENT=&amp;#39;测试表锁&amp;#39;; # 2、插入数据 INSERT INTO `mylock`(`name`) VALUES(&amp;#39;ZhangSan&amp;#39;); INSERT INTO `mylock`(`name`) VALUES(&amp;#39;LiSi&amp;#39;); INSERT INTO `mylock`(`name`) VALUES(&amp;#39;WangWu&amp;#39;); INSERT INTO `mylock`(`name`) VALUES(&amp;#39;ZhaoLiu&amp;#39;); 锁表的命令 # 1、查看数据库表锁的命令。
# 查看数据库表锁的命令 SHOW OPEN TABLES; 2、给mylock表上读锁，给book表上写锁。
# 给mylock表上读锁，给book表上写锁 LOCK TABLE `mylock` READ, `book` WRITE; # 查看当前表的状态 mysql&amp;gt; SHOW OPEN TABLES; +--------------------+------------------------------------------------------+--------+-------------+ | Database | Table | In_use | Name_locked | +--------------------+------------------------------------------------------+--------+-------------+ | sql_analysis | book | 1 | 0 | | sql_analysis | mylock | 1 | 0 | +--------------------+------------------------------------------------------+--------+-------------+ 3、释放表锁。</description></item><item><title>三种日志</title><link>https://zput.github.io/middleware/docs/mysql/advanced/log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/advanced/log/</guid><description>log # redo log # what: 物理格式日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。 why: 确保事务的持久性。 防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。 how: 什么时候产生： 事务开始之后就产生redo log，redo log的落盘并不是当事务提交时才写入的，而是在事务的执行过程中，便开始写入redo log文件中。 重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。 然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘 Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。 每个事务提交时会将重做日志刷新到重做日志文件。 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件 什么时候释放： 当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。 对应的物理文件： 默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;amp;ib_logfile2 innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。 innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2 关于文件的大小和数量，由一下两个参数配置 innodb_log_file_size 重做日志文件的大小。 innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1 undo log回滚日志 # what: 逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。 why: 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读 how: 什么时候产生： 事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性 什么时候释放： 当事务提交之后，undo log并不能立马被删除， 而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。 对应的物理文件： MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。 MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。 关于MySQL5.7之后的独立undo 表空间配置参数如下 innodb_undo_directory = /data/undospace/ &amp;ndash;undo独立表空间的存放目录 innodb_undo_logs = 128 &amp;ndash;回滚段为128KB innodb_undo_tablespaces = 4 &amp;ndash;指定有4个undo log文件 如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。 其他： undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。 默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。 因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的.</description></item><item><title>页的结构</title><link>https://zput.github.io/middleware/docs/mysql/advanced/segment_extent_page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/advanced/segment_extent_page/</guid><description>表空间的格式 # segment和extent是InnoDB内部用于分配管理页的逻辑结构(物理上不存在，只是逻辑上存在这样的上下级关系，物理上都是页组成)，用于分配与回收页，对于写入数据的性能至关重要。
但这张图有所局限性，可能会产生误解：
图中是系统表空间，因此存在rollback segment，独立表空间则没有。 leaf node segment实际是InnoDB的inode概念，一个segment可能包含最多32个碎片page、0个extent（用于小表优化），或者是非常多的extent，我猜测作者图中画了4个extent是在描述表超过32MB大小的时候一次申请4个extent。 一个extent在默认16k的page大小下，由64个page组成，page大小由UNIV_PAGE_SIZE定义，所以extent不一定由64个page组成。 表的所有行数据都存在页类型为INDEX的索引页（page）上，为了管理表空间，还需要很多其他的辅助页，例如文件管理页FSP_HDR/XDES、插入缓冲IBUF_BITMAP页、INODE页等。 页的结构 # MySQL一次IO的最小单位是页（page），也可以理解为一次原子操作都是以page为单位的，默认大小16k。刚刚列出的所有物理文件结构上都是以Page构成的，只是page内部的结构不同。
文件管理页 # 文件管理页的页类型是FSP_HDR和XDES（extent descriptor），用于分配、管理extent和page。 FSP_HDR和XDES的唯一区别，它们两者除了FSP Header这个位置在FSP_HDR有值，在XDES中是用0填充外, 其他field都一样。 FSP Header这个field，它在XDES页中是空的(zero-filled for XDES pages) ---&amp;gt; (112); page 0(FSP_HDR页面)中FSP_HDR中有值。 FSP_HDR页都是page 0，XDES页一般出现在page 16384, 32768等固定的位置。一个FSP_HDR或者XDES页大小同样是16K。 一般情况下，每个extent都有一个占40字节的XDES entry描述维护，Innodb这里定义了一个页保存256个extent描述符, 每个区描述符所在页的偏移量都是16384(256x64, 16384, 后续随着空间文件增大，XDES页会在16384,32768等位置), 换言之管理256M，16384个page）。 FSP header: 里面最重要的信息就是四个链表头尾数据（FLST_BASE_NODE结构，FLST意思是first and last），FLST_BASE_NODE如下。 1）当一个Extent中所有page都未被使用时，挂在FSP_FREE list base node上，可以用于随后的分配； 2）有一部分page被写入的extent，挂在FREE_FRAG list base node上； 3）全满的extent，挂在FULL_FRAG list base node上； 4）归属于某个segment时候挂在FSEG list base node上。 当InnoDB写入数据的时候，会从这些链表上分配或者回收extent和page，这些extent也都是在这几个链表上移动的。 XDES entry 存储所管理的extent状态： 1）FREE（空） 2）FREE_FRAG（至少一个被占用） 3）FULL_FRAG（满） 4）归某个segment管理的信息 XDES entry还存储了每个extent内部page是否free（有空间）信息（用bitmap表示）。XDES entry组成了一个双向链表，同一种extent状态的收尾连在一起，便于管理。 INODE页 # what:</description></item></channel></rss>