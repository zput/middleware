<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="goroutine被动调度 # 什么是被动调度: goroutine执行某个操作因条件不满足需要等待而发生的调度
goroutine进入睡眠 比如是goroutineN发送数据到无缓冲chan上面,当没有其他Goroutine从chan上面读数据的时候,goroutineN阻塞在chan上面. 此刻睡眠含义:进入chan的缓存读取队列(goroutine链表) 重新运行schedule() 唤醒睡眠中的goroutine; 唤醒空闲的P和唤醒/创建工作线程; goroutine(被创建出来后/创建运行了一段时间后)如何放入运行队列P中 被动进入睡眠 # goroutine因某个条件而阻塞 chan waitGroup 等这些都会发生阻塞 package main import ( &#34;fmt&#34; &#34;runtime&#34; &#34;sync&#34; &#34;sync/atomic&#34; ) func main() { var n int32 var wg sync.WaitGroup runtime.GOMAXPROCS(2) wg.Add(1) go func() { wg.Done() for{ atomic.AddInt32(&n, 1) } }() wg.Wait() fmt.Println(atomic.LoadInt32(&n)) // 1 } gdb调试前准备 # 编译程序 # 编译一下源代码: go build -gcflags &#34;-N -l&#34; -o test ..
准备mcall函数断点的文件 # 进入wg.Wait()
我们都知道main函数里面的wg.Wait()这个只有当wg的计数器到0后才会继续执行,来看看当wg还没有到0的时候,这里会发生什么呢?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // src/sync/waitgroup."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="被动调度"><meta property="og:description" content="goroutine被动调度 # 什么是被动调度: goroutine执行某个操作因条件不满足需要等待而发生的调度
goroutine进入睡眠 比如是goroutineN发送数据到无缓冲chan上面,当没有其他Goroutine从chan上面读数据的时候,goroutineN阻塞在chan上面. 此刻睡眠含义:进入chan的缓存读取队列(goroutine链表) 重新运行schedule() 唤醒睡眠中的goroutine; 唤醒空闲的P和唤醒/创建工作线程; goroutine(被创建出来后/创建运行了一段时间后)如何放入运行队列P中 被动进入睡眠 # goroutine因某个条件而阻塞 chan waitGroup 等这些都会发生阻塞 package main import ( &#34;fmt&#34; &#34;runtime&#34; &#34;sync&#34; &#34;sync/atomic&#34; ) func main() { var n int32 var wg sync.WaitGroup runtime.GOMAXPROCS(2) wg.Add(1) go func() { wg.Done() for{ atomic.AddInt32(&n, 1) } }() wg.Wait() fmt.Println(atomic.LoadInt32(&n)) // 1 } gdb调试前准备 # 编译程序 # 编译一下源代码: go build -gcflags &#34;-N -l&#34; -o test ..
准备mcall函数断点的文件 # 进入wg.Wait()
我们都知道main函数里面的wg.Wait()这个只有当wg的计数器到0后才会继续执行,来看看当wg还没有到0的时候,这里会发生什么呢?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // src/sync/waitgroup."><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2020-04-15T11:33:07+00:00"><meta property="article:modified_time" content="2020-04-15T11:33:07+00:00"><title>被动调度 | go调度源码分析</title><link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png type=image/x-icon><link rel=stylesheet href=/go-goroutine/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script>
<script defer src=/go-goroutine/en.search.min.75f3025a21511955ad10f181cae208dd296ce24ee2a06def487a11decfa675f1.js integrity="sha256-dfMCWiFRGVWtEPGByuII3Sls4k7ioG3vSHoR3s+mdfE=" crossorigin=anonymous></script>
<script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/ class=active>被动调度</a></li><li><input type=checkbox id=section-99f41010918d678e89a7af90330cabe1 class=toggle>
<label for=section-99f41010918d678e89a7af90330cabe1 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>执行太久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>系统调用抢占</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script>
<script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu></label>
<strong>被动调度</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#goroutine被动调度>goroutine被动调度</a><ul><li><a href=#被动进入睡眠>被动进入睡眠</a><ul><li><a href=#gdb调试前准备>gdb调试前准备</a></li><li><a href=#runtime_semacquire>runtime_Semacquire</a></li><li><a href=#sync_runtime_semacquire>sync_runtime_Semacquire</a></li><li><a href=#gopark>gopark</a></li><li><a href=#park_m>park_m</a></li></ul></li><li><a href=#唤醒睡眠中的goroutine>唤醒睡眠中的goroutine</a><ul><li><a href=#runtime_semrelease>runtime_Semrelease</a></li><li><a href=#readywithtime>readyWithTime</a></li><li><a href=#goready>goready</a></li><li><a href=#runqput>runqput</a></li><li><a href=#wakep>wakep</a></li></ul></li><li><a href=#分析wakep>分析wakep</a><ul><li><a href=#startm>startm</a></li><li><a href=#mget从全局空闲m队列获取m>mget从全局空闲M队列获取m</a></li><li><a href=#newm创建新的线程与m>newm创建新的线程与m</a></li><li><a href=#notewakeup唤醒m>notewakeup唤醒m</a></li></ul></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=goroutine被动调度>goroutine被动调度
<a class=anchor href=#goroutine%e8%a2%ab%e5%8a%a8%e8%b0%83%e5%ba%a6>#</a></h1><p>什么是被动调度: goroutine执行某个操作因条件不满足需要等待而发生的调度</p><ul><li>goroutine进入睡眠<ul><li>比如是goroutineN发送数据到无缓冲chan上面,当没有其他Goroutine从chan上面读数据的时候,goroutineN阻塞在chan上面. 此刻睡眠含义:进入chan的缓存读取队列(goroutine链表)</li></ul></li><li>重新运行schedule()</li><li>唤醒睡眠中的goroutine;</li><li>唤醒空闲的P和唤醒/创建工作线程;<ul><li>goroutine(<em>被创建出来后/创建运行了一段时间后</em>)如何放入运行队列P中</li></ul></li></ul><h2 id=被动进入睡眠>被动进入睡眠
<a class=anchor href=#%e8%a2%ab%e5%8a%a8%e8%bf%9b%e5%85%a5%e7%9d%a1%e7%9c%a0>#</a></h2><div class="book-columns flex flex-wrap"><div class="flex-even markdown-inner"><ul><li>goroutine因某个条件而阻塞</li><li>chan</li><li>waitGroup
等这些都会发生阻塞</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;runtime&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync/atomic&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>)) <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></div><div class="flex-even markdown-inner"><p align=middle><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220624235343.png width=40% height=30% alt=进入睡眠></div></div><h3 id=gdb调试前准备>gdb调试前准备
<a class=anchor href=#gdb%e8%b0%83%e8%af%95%e5%89%8d%e5%87%86%e5%a4%87>#</a></h3><h4 id=编译程序>编译程序
<a class=anchor href=#%e7%bc%96%e8%af%91%e7%a8%8b%e5%ba%8f>#</a></h4><p>编译一下源代码: <code>go build -gcflags "-N -l" -o test .</code>.</p><h4 id=准备mcall函数断点的文件>准备mcall函数断点的文件
<a class=anchor href=#%e5%87%86%e5%a4%87mcall%e5%87%bd%e6%95%b0%e6%96%ad%e7%82%b9%e7%9a%84%e6%96%87%e4%bb%b6>#</a></h4><p>进入<code>wg.Wait()</code></p><p>我们都知道main函数里面的wg.Wait()这个只有当wg的计数器到0后才会继续执行,来看看当wg还没有到0的时候,这里会发生什么呢?</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/sync/waitgroup.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Wait blocks until the WaitGroup counter is zero.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>) <span style=color:#a6e22e>Wait</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>statep</span>, <span style=color:#a6e22e>semap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>state</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>//....省去race代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>state</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadUint64</span>(<span style=color:#a6e22e>statep</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> int32(<span style=color:#a6e22e>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#a6e22e>state</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Counter is 0, no need to wait.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>//....省去race代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Increment waiters count.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>CompareAndSwapUint64</span>(<span style=color:#a6e22e>statep</span>, <span style=color:#a6e22e>state</span>, <span style=color:#a6e22e>state</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//....省去race代码
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>			<span style=color:#a6e22e>runtime_Semacquire</span>(<span style=color:#a6e22e>semap</span>) <span style=color:#75715e>// PV操作  ---------------------here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>statep</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>				panic(<span style=color:#e6db74>&#34;sync: WaitGroup is reused before previous Wait has returned&#34;</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Enabled</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Enable</span>()
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Acquire</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>wg</span>))
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}</span></span></code></pre></td></tr></table></div></div><h3 id=runtime_semacquire>runtime_Semacquire
<a class=anchor href=#runtime_semacquire>#</a></h3><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/sync/runtime.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Semacquire waits until *s &gt; 0 and then atomically decrements it.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// It is intended as a simple sleep primitive for use by the synchronization
</span></span></span><span style=display:flex><span><span style=color:#75715e>// library and should not be used directly.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runtime_Semacquire</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>)
</span></span></code></pre></div><p>这里类似PV操作, 但是:</p><ul><li>P:等待直到(*s)大于0, 然后才自动减(也就是如果是等于0, 那么就会休眠)</li><li>v:首先自动增加(*s),唤醒被等待的goroutine.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/sync/runtime.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Semacquire waits until *s &gt; 0 and then atomically decrements it.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// It is intended as a simple sleep primitive for use by the synchronization
</span></span></span><span style=display:flex><span><span style=color:#75715e>// library and should not be used directly.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runtime_Semacquire</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>)
</span></span></code></pre></div><p>继续下去发现找不到定义了, 我们gdb查找一下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>list</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>lib</span><span style=color:#f92672>/</span><span style=color:#a6e22e>golang</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>/</span><span style=color:#a6e22e>waitgroup</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>130</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span> <span style=color:#ae81ff>130</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>list</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>lib</span><span style=color:#f92672>/</span><span style=color:#a6e22e>golang</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>/</span><span style=color:#a6e22e>runtime</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span> <span style=color:#ae81ff>130</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>gdb</span>) <span style=color:#a6e22e>info</span> <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Num</span>     <span style=color:#a6e22e>Type</span>           <span style=color:#a6e22e>Disp</span> <span style=color:#a6e22e>Enb</span> <span style=color:#a6e22e>Address</span>            <span style=color:#a6e22e>What</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>       <span style=color:#a6e22e>breakpoint</span>     <span style=color:#a6e22e>keep</span> <span style=color:#a6e22e>y</span>   <span style=color:#ae81ff>0x0000000000466bfb</span> <span style=color:#a6e22e>in</span> <span style=color:#a6e22e>sync</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>).<span style=color:#a6e22e>Wait</span> <span style=color:#a6e22e>at</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>lib</span><span style=color:#f92672>/</span><span style=color:#a6e22e>golang</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>/</span><span style=color:#a6e22e>waitgroup</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>130</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>       <span style=color:#a6e22e>breakpoint</span>     <span style=color:#a6e22e>keep</span> <span style=color:#a6e22e>y</span>   <span style=color:#ae81ff>0x00000000004669c0</span> <span style=color:#a6e22e>in</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>init</span><span style=color:#ae81ff>.1</span> <span style=color:#a6e22e>at</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>lib</span><span style=color:#f92672>/</span><span style=color:#a6e22e>golang</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>/</span><span style=color:#a6e22e>runtime</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>gdb</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>gdb</span>) <span style=color:#a6e22e>step</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>runtime_Semacquire</span> (<span style=color:#a6e22e>addr</span>=<span style=color:#ae81ff>0xc00007e014</span>) <span style=color:#a6e22e>at</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>lib</span><span style=color:#f92672>/</span><span style=color:#a6e22e>golang</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>runtime</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sema</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>55</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>55</span>	<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sync_runtime_Semacquire</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>) {
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>gdb</span>) <span style=color:#a6e22e>frame</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>0</span>  <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>runtime_Semacquire</span> (<span style=color:#a6e22e>addr</span>=<span style=color:#ae81ff>0xc00007e014</span>) <span style=color:#a6e22e>at</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>lib</span><span style=color:#f92672>/</span><span style=color:#a6e22e>golang</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>runtime</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sema</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>55</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>55</span>	<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sync_runtime_Semacquire</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>) {
</span></span></code></pre></div></blockquote><h3 id=sync_runtime_semacquire>sync_runtime_Semacquire
<a class=anchor href=#sync_runtime_semacquire>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span></span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// /src/runtime/sema.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:linkname sync_runtime_Semacquire sync.runtime_Semacquire
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sync_runtime_Semacquire</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>semacquire1</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>semaBlockProfile</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>semacquire1</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>lifo</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>profile</span> <span style=color:#a6e22e>semaProfileFlags</span>, <span style=color:#a6e22e>skipframes</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span> {
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;semacquire not on the G stack&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Easy case.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cansemacquire</span>(<span style=color:#a6e22e>addr</span>) {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Harder case:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	increment waiter count
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	try cansemacquire one more time, return if succeeded
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	enqueue itself as a waiter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	sleep
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	(waiter descriptor is dequeued by signaler)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>semroot</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t0</span> <span style=color:#f92672>:=</span> int64(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>acquiretime</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ticket</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>profile</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>semaBlockProfile</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>blockprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>profile</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>semaMutexProfile</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>mutexprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t0</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>acquiretime</span> = <span style=color:#a6e22e>t0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Add ourselves to nwait to disable &#34;easy case&#34; in semrelease.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Check cansemacquire to avoid missed wakeup.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cansemacquire</span>(<span style=color:#a6e22e>addr</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Any semrelease after the cansemacquire knows we&#39;re waiting
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// (we set nwait above), so go to sleep.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>queue</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>lifo</span>)
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#a6e22e>goparkunlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>waitReasonSemacquire</span>, <span style=color:#a6e22e>traceEvGoBlockSync</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>+</span><span style=color:#a6e22e>skipframes</span>) <span style=color:#75715e>// 进入睡眠 ---------------------here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ticket</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>cansemacquire</span>(<span style=color:#a6e22e>addr</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>+</span><span style=color:#a6e22e>skipframes</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>}</span></span></code></pre></td></tr></table></div></div><blockquote><p>这里的sema变量, 如果是等于0(它是无符号整形,不会为负数),就代表它没有获取到sema,需要等待,
如果sema变量是大于0,可以直接运行,不需要等待</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>cansemacquire</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>v</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们知道sync.WaitGroup()函数, 一般是先Add(), 然后Wait()等待所有任务Done()[Add(-1)]
sema开始值是0,按照我们前面说的,他无法获得sema,会进行休眠,同理如果有多个Wait(), 那么它们都会
休眠; 当Add(-1)后到达0后, 就是所有任务都已经完成,它会调用<code>runtime_Semrelease(semap, false, 0) // 进行V操作</code>进行sema值加一,
然后唤醒一个goroutine, 当这个goroutine醒来[在一个loop里面], 发现sema不等于0了, 直接减一,然后跳出了<code>semacquire1</code></p><p>关于WaitGroup的分析, 参看我其他的文章.继续分析这个休眠和唤醒的;</p></blockquote><h3 id=gopark>gopark
<a class=anchor href=#gopark>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/proc.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Puts the current goroutine into a waiting state and unlocks the lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The goroutine can be made runnable again by calling goready(gp).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>goparkunlock</span>(<span style=color:#a6e22e>lock</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mutex</span>, <span style=color:#a6e22e>reason</span> <span style=color:#a6e22e>waitReason</span>, <span style=color:#a6e22e>traceEv</span> <span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>parkunlock_c</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>lock</span>), <span style=color:#a6e22e>reason</span>, <span style=color:#a6e22e>traceEv</span>, <span style=color:#a6e22e>traceskip</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Puts the current goroutine into a waiting state and calls unlockf.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If unlockf returns false, the goroutine is resumed.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// unlockf must not access this G&#39;s stack, as it may be moved between
</span></span></span><span style=display:flex><span><span style=color:#75715e>// the call to gopark and the call to unlockf.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Reason explains why the goroutine has been parked.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// It is displayed in stack traces and heap dumps.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Reasons should be unique and descriptive.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Do not re-use reasons, add new ones.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>reason</span> <span style=color:#a6e22e>waitReason</span>, <span style=color:#a6e22e>traceEv</span> <span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>reason</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>waitReasonSleep</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>checkTimeouts</span>() <span style=color:#75715e>// timeouts may expire while two goroutines keep the scheduler busy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquirem</span>() <span style=color:#75715e>// 这里的作用是什么?  ---------wait
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>curg</span>    <span style=color:#75715e>// 得到当前的Goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>status</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>readgstatus</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>status</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_Grunning</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>status</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_Gscanrunning</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;gopark: bad g status&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waitlock</span> = <span style=color:#a6e22e>lock</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waitunlockf</span> = <span style=color:#a6e22e>unlockf</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waitreason</span> = <span style=color:#a6e22e>reason</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waittraceev</span> = <span style=color:#a6e22e>traceEv</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waittraceskip</span> = <span style=color:#a6e22e>traceskip</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>)   <span style=color:#75715e>// ---------wait
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// can&#39;t do anything that might move the G between Ms here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>park_m</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>mcall就是切换到g0栈上去,gN的cpu寄存器等保存到g&rsquo;sched,然后把gN作为实参给mcall的fn形参,
继续看park_m.</p><h3 id=park_m>park_m
<a class=anchor href=#park_m>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// park continuation on g0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>park_m</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()  <span style=color:#75715e>// 得到g0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>traceGoPark</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>waittraceev</span>, <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>waittraceskip</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gwaiting</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dropg</span>()<span style=color:#75715e>//解除gN与m的关系
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>waitunlockf</span>; <span style=color:#a6e22e>fn</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fn</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>waitlock</span>) <span style=color:#75715e>//解除lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>waitunlockf</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>waitlock</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>traceGoUnpark</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gwaiting</span>, <span style=color:#a6e22e>_Grunnable</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>true</span>) <span style=color:#75715e>// Schedule it back, never returns.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>schedule</span>() <span style=color:#75715e>//重新进入调度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><blockquote><p>dropg函数，参见&lt;前置知识.类汇编></p><p>进入睡眠的步骤:<code>goparkunlock --> gopark --> mcall(park_m) --> schedule</code>.</p></blockquote><h2 id=唤醒睡眠中的goroutine>唤醒睡眠中的goroutine
<a class=anchor href=#%e5%94%a4%e9%86%92%e7%9d%a1%e7%9c%a0%e4%b8%ad%e7%9a%84goroutine>#</a></h2><p>唤醒的总体流程如下图:</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220625002224.png alt=20220625002224></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>) <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>delta</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>statep</span>, <span style=color:#a6e22e>semap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>state</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Enabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span> = <span style=color:#f92672>*</span><span style=color:#a6e22e>statep</span> <span style=color:#75715e>// trigger nil deref early
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>delta</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Synchronize decrements with Wait.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>ReleaseMerge</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>wg</span>))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Disable</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Enable</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>state</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddUint64</span>(<span style=color:#a6e22e>statep</span>, uint64(<span style=color:#a6e22e>delta</span>)<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> int32(<span style=color:#a6e22e>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#a6e22e>state</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Enabled</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>delta</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> int32(<span style=color:#a6e22e>delta</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The first increment must be synchronized with Wait.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Need to model this as a read, because there can be
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// several concurrent wg.counter transitions from 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>race</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>semap</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;sync: negative WaitGroup counter&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>delta</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> int32(<span style=color:#a6e22e>delta</span>) {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// This goroutine has set counter to 0 when waiters &gt; 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Now there can&#39;t be concurrent mutations of state:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// - Adds must not happen concurrently with Wait,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// - Wait does not increment waiters if it sees counter == 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Still do a cheap sanity check to detect WaitGroup misuse.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>statep</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>state</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Reset waiters count to 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>statep</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>w</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>w</span><span style=color:#f92672>--</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>runtime_Semrelease</span>(<span style=color:#a6e22e>semap</span>, <span style=color:#66d9ef>false</span>, <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// 进行V操作    --------------------------------here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=runtime_semrelease>runtime_Semrelease
<a class=anchor href=#runtime_semrelease>#</a></h3><blockquote><p>src/sync/runtime.go</p></blockquote><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span></span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span></span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span></span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sync_runtime_Semrelease</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>handoff</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>skipframes</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>semrelease1</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>handoff</span>, <span style=color:#a6e22e>skipframes</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>semrelease1</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>handoff</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>skipframes</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>semroot</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Easy case: no waiters?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// This check must happen after the xadd, to avoid a missed wakeup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (see loop in semacquire).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Harder case: search for a waiter and wake it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The count is already consumed by another goroutine,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// so no need to wake up another goroutine.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>t0</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>dequeue</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>nwait</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// May be slow, so unlock first
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>acquiretime</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>acquiretime</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>acquiretime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>mutexevent</span>(<span style=color:#a6e22e>t0</span><span style=color:#f92672>-</span><span style=color:#a6e22e>acquiretime</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>+</span><span style=color:#a6e22e>skipframes</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ticket</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;corrupted semaphore ticket&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>handoff</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>cansemacquire</span>(<span style=color:#a6e22e>addr</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ticket</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#a6e22e>readyWithTime</span>(<span style=color:#a6e22e>s</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>+</span><span style=color:#a6e22e>skipframes</span>)    <span style=color:#75715e>// ------------------------------here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}</span></span></code></pre></td></tr></table></div></div><h3 id=readywithtime>readyWithTime
<a class=anchor href=#readywithtime>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>readyWithTime</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>traceskip</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=goready>goready
<a class=anchor href=#goready>#</a></h3><p>前面都很好理解, 这里有两个函数, 一个是<code>systemstack</code>, 一个是<code>ready</code>函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>traceskip</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Mark gp ready to run.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ready</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>next</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span> { <span style=color:#75715e>//忽略
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>traceGoUnpark</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>traceskip</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>status</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>readgstatus</span>(<span style=color:#a6e22e>gp</span>) <span style=color:#75715e>// return atomic.Load(&amp;gp.atomicstatus)读atomicstatus的状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Mark runnable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquirem</span>() <span style=color:#75715e>// disable preemption because it can be holding p in a local var
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>status</span><span style=color:#f92672>&amp;^</span><span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_Gwaiting</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>dumpgstatus</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;bad g-&gt;status in ready&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gwaiting</span>, <span style=color:#a6e22e>_Grunnable</span>) <span style=color:#75715e>// 修改状态到_Grunnable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>runqput</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>(), <span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>next</span>) <span style=color:#75715e>// 放入全局或本地队列,等待调度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmspinning</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 有空闲的P,并且没有正在自旋状态的M(偷取其他线程的goroutine);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// 那么需要唤醒P.万一就把上面的待运行的goroutine调度起来了呢?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>wakep</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sync_runtime_Semrelease ---&gt; semrelease1 ---&gt; readyWithTime ---&gt; goready --systemstack-&gt; ready
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ready---&gt; runqput -------------&gt; releasem
</span></span><span style=display:flex><span>                  <span style=color:#ae81ff>\-</span>-&gt;wakep-/
</span></span></code></pre></div><h3 id=runqput>runqput
<a class=anchor href=#runqput>#</a></h3><p>其中runqput是,当从<code>s, t0 := root.dequeue(addr)</code>得到睡眠中的Goroutine,修改状态为<code>_Grunnable</code>,然后放入本地或全局队列</p><hr><p>runqput的具体实现可以参见:
<a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/#runqput class="book-btn ...">runqput</a></p><h3 id=wakep>wakep
<a class=anchor href=#wakep>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span></span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ready</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>next</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>runqput</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>(), <span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>next</span>) <span style=color:#75715e>// 放入全局或本地队列,等待调度
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmspinning</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#75715e>// 有空闲的P,并且没有正在自旋状态的M(偷取其他线程的goroutine);
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>		<span style=color:#75715e>// 那么需要唤醒P.万一就把上面的待运行的goroutine调度起来了呢?
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>		<span style=color:#a6e22e>wakep</span>()
</span></span><span style=display:flex;background-color:#3c3d38><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>)
</span></span><span style=display:flex><span>}</span></span></code></pre></td></tr></table></div></div><p>如果<strong>有空闲的P</strong>,并且<strong>没有正在自旋状态的M</strong>(<del>换言之所有的M都在工作?</del>,换言之M都是运行/睡眠状态),这种状态成立,那么就会进行执行wakep函数</p><ul><li>什么时候P变成了空闲了:
<a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/#P%e7%9a%84%e7%8a%b6%e6%80%81 class="book-btn ...">P空闲状态</a></li><li>什么时候M变成了自旋状态了:
<a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/#M%e7%9a%84%e7%8a%b6%e6%80%81 class="book-btn ...">M自旋转</a></li><li>为什么要满足这两个状态才进行唤醒:<ul><li>1> 有空闲的P才能进行唤醒,如果都没空闲的了,唤醒也没用</li><li>2> 自旋状态的M是一直在伺机偷其他P队列g的,如果有自旋状态的M那么就不需要再专门唤醒</li></ul></li><li>不唤醒可以?: 去掉这个唤醒逻辑,正常来说此goroutine还是有几率被快速执行,只是对整个系统来说,只要P空闲,<del>M睡眠了</del>,就没有逻辑唤醒它们</li></ul><h2 id=分析wakep>分析wakep
<a class=anchor href=#%e5%88%86%e6%9e%90wakep>#</a></h2><p>wakep主要是唤醒一个空闲P,获得/创建一个M,开始轮询调度,为了把上面已唤醒的G调度起来</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Tries to add one more P to execute G&#39;s.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Called when a G is made runnable (newproc, ready).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>wakep</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// be conservative about spinning threads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmspinning</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>startm</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>一个P只能找到M,从空闲的M中找? 然后通过m.g0找到.</li><li>生成新的M,此时,创造新的线程,因为M与线程是一一对应的,同时它也会创造一个g0.</li></ul><p>这里重新再判断一下是否有自旋的M,如果还是没有就设置自旋M的数量为1,<del>后面<code>startm</code>函数准备创建/唤醒一个M</del>(觉得还是为了避免wakep被其他线程再次进入执行,后面会让新建/唤醒的M的状态设置为自旋)</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20220625232035.png alt=20220625232035></p><h3 id=startm>startm
<a class=anchor href=#startm>#</a></h3><p>继续看下startm:可以发现主要是尝试用mget函数从全局空闲M队列获取一个M,如果失败是调用newm函数准备创建一个M,否则就用notewakeup去唤醒刚获取的M,这里有一点是为了保证nmspinning数据一致性,把新建/唤醒的M的状态设置为自旋</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>startm</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>spinning</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#a6e22e>_p_</span> = <span style=color:#a6e22e>pidleget</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>spinning</span> {
</span></span><span style=display:flex><span>				<span style=color:#75715e>// The caller incremented nmspinning, but there are no idle Ps,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#75715e>// so it&#39;s okay to just undo the increment and give up.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#66d9ef>if</span> int32(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmspinning</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;startm: negative nmspinning&#34;</span>)
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mget</span>()
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>) <span style=color:#75715e>// 全局空闲M队列
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>//从全局的空闲队列没找到M
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>func</span>()
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>spinning</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>			<span style=color:#75715e>// The caller incremented nmspinning, so set m.spinning in the new M.
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>			<span style=color:#a6e22e>fn</span> = <span style=color:#a6e22e>mspinning</span>
</span></span><span style=display:flex;background-color:#3c3d38><span>		}
</span></span><span style=display:flex;background-color:#3c3d38><span>		<span style=color:#a6e22e>newm</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>_p_</span>) <span style=color:#75715e>//新创建一个M,其中里面也有新g0.
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#75715e>// 这里如果是新创建的线程,那么直接返回,不需要继续下面的唤醒notewakeup(&amp;mp.park)
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>spinning</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;startm: m is spinning&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>nextp</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;startm: m has p&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>spinning</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>runqempty</span>(<span style=color:#a6e22e>_p_</span>) { <span style=color:#75715e>// _p_它的可运行G队列应该为空 &gt;一种情况是它是从空闲P队列获得的(pidleget()函数)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;startm: p has runnable gs&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The caller incremented nmspinning, so set m.spinning in the new M.
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#75715e>// 因为startm的调用者已经把自旋M数量+1,所以这里为了数据一致,必须把这个M设置为自旋状态
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>spinning</span> = <span style=color:#a6e22e>spinning</span>
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>nextp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>_p_</span>)
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>park</span>) <span style=color:#75715e>// 到这一步,那么M是从全局空闲M队列获得的Ms,那么需要唤醒.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div><h3 id=mget从全局空闲m队列获取m>mget从全局空闲M队列获取m
<a class=anchor href=#mget%e4%bb%8e%e5%85%a8%e5%b1%80%e7%a9%ba%e9%97%b2m%e9%98%9f%e5%88%97%e8%8e%b7%e5%8f%96m>#</a></h3><p>这个全局的空闲M队列,从下面的函数取出,它就是一个链表,通过schedlink指针来串联所有空闲的M.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//尝试从全局的(sched.midle列表中得到一个m)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Try to get an m from midle list.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Sched must be locked.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// May run during STW, so write barriers are not allowed.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//go:nowritebarrierrec
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mget</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>midle</span>.<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>midle</span> = <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>schedlink</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmidle</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mp</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>schedt</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>midle</span>        <span style=color:#a6e22e>muintptr</span> <span style=color:#75715e>// idle m&#39;s waiting for work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nmidle</span>       <span style=color:#66d9ef>int32</span>    <span style=color:#75715e>// number of idle m&#39;s waiting for work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// muintptr类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>muintptr</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//go:nosplit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>mp</span> <span style=color:#a6e22e>muintptr</span>) <span style=color:#a6e22e>ptr</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span> { <span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>)) }
</span></span><span style=display:flex><span><span style=color:#75715e>//go:nosplit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>mp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>muintptr</span>) <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>) { <span style=color:#f92672>*</span><span style=color:#a6e22e>mp</span> = <span style=color:#a6e22e>muintptr</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>m</span>)) }
</span></span></code></pre></div><p>下面我们回到前面来看另一种情况:直接创建新M</p><h3 id=newm创建新的线程与m>newm创建新的线程与m
<a class=anchor href=#newm%e5%88%9b%e5%bb%ba%e6%96%b0%e7%9a%84%e7%ba%bf%e7%a8%8b%e4%b8%8em>#</a></h3><p>新创建一个M,其中里面也有新g0</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newm</span>(<span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//分配一个与任何线程无关的M结构体mp,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// mp.g0=Gorooutine(也是从这里面分配出来的)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>allocm</span>(<span style=color:#a6e22e>_p_</span>, <span style=color:#a6e22e>fn</span>) 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>nextp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>_p_</span>) <span style=color:#75715e>//把M关联上P
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>sigmask</span> = <span style=color:#a6e22e>initSigmask</span> <span style=color:#75715e>//初始化信号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>(); <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lockedExt</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>incgo</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>GOOS</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;plan9&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// We&#39;re on a locked M or a thread that may have been
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// started by C. The kernel state of this thread may
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// be strange (the user may have locked it for that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// purpose). We don&#39;t want to clone that into another
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// thread. Instead, ask a known-good thread to create
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// the thread for us.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// This is disabled on Plan 9. See golang.org/issue/22227.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// TODO: This may be unnecessary on Windows, which
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// doesn&#39;t model thread creation off fork.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newmHandoff</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newmHandoff</span>.<span style=color:#a6e22e>haveTemplateThread</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;on a locked thread with no template thread&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>schedlink</span> = <span style=color:#a6e22e>newmHandoff</span>.<span style=color:#a6e22e>newm</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>newmHandoff</span>.<span style=color:#a6e22e>newm</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>mp</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newmHandoff</span>.<span style=color:#a6e22e>waiting</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>newmHandoff</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newmHandoff</span>.<span style=color:#a6e22e>wake</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newmHandoff</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>newm1</span>(<span style=color:#a6e22e>mp</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>newm函数主要是两件事:<ul><li>创建M结构体,G结构体(用于前面m.g0)在stack上开辟空间给g0.stack.<ul><li>allocm()</li></ul></li><li>创建一个真正的线程,与上面的M结构相关联.<ul><li>newm1()方式,<ul><li>直接从当前线程clone出一个新的线程.</li></ul></li><li>newmHandoff方式 [TODO zxc:可以新开一章来讲解]<ul><li>给一个一直在for循环的创建线程,然后休眠的函数来创建线程,关联上面的M结构体</li></ul></li></ul></li></ul></li></ul><h4 id=allocm函数>allocm函数
<a class=anchor href=#allocm%e5%87%bd%e6%95%b0>#</a></h4><blockquote><ul><li>因为函数需要new小对象,需要用到P.mcache,需要判断当前的M是否关联着P,如果没有就要向参数借,但是为什么没有判断如果参数_P_是nil的情况?</li><li>释放不需要等待的全局的M&rsquo;s stack资源,这里是防止新生成线程又需要stack空间,所以先释放一些?</li><li>new M, g0结构体,并且给g0分配stack空间.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Allocate a new m unassociated with any thread.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Can use p for allocation context if needed.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// fn is recorded as the new m&#39;s m.mstartfn.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This function is allowed to have write barriers even if the caller
</span></span></span><span style=display:flex><span><span style=color:#75715e>// isn&#39;t because it borrows _p_.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>//go:yeswritebarrierrec
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>allocm</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>func</span>()) <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>acquirem</span>() <span style=color:#75715e>// disable GC because it can be called from sysmon 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	 <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	func acquirem() *m {
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 	_g_ := getg()
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 	_g_.m.locks++
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 	return _g_.m
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 } 
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 TODO zxc: 这里很奇怪的,只是把M结构体里面的locks字段++1; 后面的releasem又把这个locks--?
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 func releasem(mp *m) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 	_g_ := getg()
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 	mp.locks--
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 	if mp.locks == 0 &amp;&amp; _g_.preempt {
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 		// restore the preemption request in case we&#39;ve cleared it in newstack
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 		_g_.stackguard0 = stackPreempt
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 	}
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 }
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>//如果当前m的P不存在,acquirep(_p_)关联_p_和当前的M;只是用于小对象的分配到堆上? TODO zxc: 这里P.mcahce,就是M.mcache
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>acquirep</span>(<span style=color:#a6e22e>_p_</span>) <span style=color:#75715e>// temporarily borrow p for mallocs in this function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Release the free M list. We need to do this somewhere and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// this may free up a stack we can use.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>freem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>newList</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>freem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>freem</span>; <span style=color:#a6e22e>freem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>freem</span>.<span style=color:#a6e22e>freeWait</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// if == 0, 安全释放g0并删除m; 这里如果不等于0,就说明需要等待,还不能立即释放,所以这个if里面就好像链表反转算法,转移到新链表.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>next</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>freem</span>.<span style=color:#a6e22e>freelink</span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>freem</span>.<span style=color:#a6e22e>freelink</span> = <span style=color:#a6e22e>newList</span> <span style=color:#75715e>//freem.freelink = newList(nil); so, freem.freelink == nil 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>newList</span> = <span style=color:#a6e22e>freem</span> <span style=color:#75715e>// newList.freelink == nil; freem == newList 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>freem</span> = <span style=color:#a6e22e>next</span>    <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#66d9ef>continue</span> 
</span></span><span style=display:flex><span>			} 
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>stackfree</span>(<span style=color:#a6e22e>freem</span>.<span style=color:#a6e22e>g0</span>.<span style=color:#a6e22e>stack</span>) <span style=color:#75715e>// 说明freem.freeWait==0;可以立即g0 stack释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>freem</span> = <span style=color:#a6e22e>freem</span>.<span style=color:#a6e22e>freelink</span>  <span style=color:#75715e>// freem等于它的next指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>freem</span> = <span style=color:#a6e22e>newList</span> <span style=color:#75715e>//这里就把不能释放的重新放入全局释放列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>m</span>) <span style=color:#75715e>// new一个M结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>mstartfn</span> = <span style=color:#a6e22e>fn</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mcommoninit</span>(<span style=color:#a6e22e>mp</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Windows and Plan 9 will layout sched stack on OS stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>iscgo</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>GOOS</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;solaris&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>GOOS</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;illumos&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>GOOS</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;windows&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>GOOS</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;plan9&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>GOOS</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;darwin&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span> = <span style=color:#a6e22e>malg</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span> = <span style=color:#a6e22e>malg</span>(<span style=color:#ae81ff>8192</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>StackGuardMultiplier</span>) <span style=color:#75715e>//约等于1024*8=8192 ==&gt; 8k
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span>.<span style=color:#a6e22e>m</span> = <span style=color:#a6e22e>mp</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_p_</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>() { <span style=color:#75715e>//如果是借P来进行malloc,那么需要恢复原样.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>releasep</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>) <span style=color:#75715e>// TODO zxc: locks ?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mp</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为什么需要locks&ndash;?</p></blockquote><hr><h4 id=newm1>newm1
<a class=anchor href=#newm1>#</a></h4><blockquote><p>newm1先关闭信号,防止clone时候被打断.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newm1</span>(<span style=color:#a6e22e>mp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>iscgo</span> {  <span style=color:#75715e>// 暂时忽略.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>execLock</span>.<span style=color:#a6e22e>rlock</span>() <span style=color:#75715e>// Prevent process clone.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>newosproc</span>(<span style=color:#a6e22e>mp</span>)   <span style=color:#75715e>//准备去clone.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>execLock</span>.<span style=color:#a6e22e>runlock</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newosproc</span>(<span style=color:#a6e22e>mp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>stk</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * note: strace gets confused if we use CLONE_PTRACE here.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>false</span> {
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>&#34;newosproc stk=&#34;</span>, <span style=color:#a6e22e>stk</span>, <span style=color:#e6db74>&#34; m=&#34;</span>, <span style=color:#a6e22e>mp</span>, <span style=color:#e6db74>&#34; g=&#34;</span>, <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span>, <span style=color:#e6db74>&#34; clone=&#34;</span>, <span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>clone</span>), <span style=color:#e6db74>&#34; id=&#34;</span>, <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>id</span>, <span style=color:#e6db74>&#34; ostk=&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mp</span>, <span style=color:#e6db74>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Disable signals during clone, so that the new thread starts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// with signals disabled. It will enable them in minit.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 在clone,关闭信号,所以创建出来的thread信号都是关闭的,minit函数再打开.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>oset</span> <span style=color:#a6e22e>sigset</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sigprocmask</span>(<span style=color:#a6e22e>_SIG_SETMASK</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sigset_all</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>oset</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ret</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>clone</span>(<span style=color:#a6e22e>cloneFlags</span>, <span style=color:#a6e22e>stk</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span>), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>mstart</span>)))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sigprocmask</span>(<span style=color:#a6e22e>_SIG_SETMASK</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>oset</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ret</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>&#34;runtime: failed to create new OS thread (have &#34;</span>, <span style=color:#a6e22e>mcount</span>(), <span style=color:#e6db74>&#34; already; errno=&#34;</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>ret</span>, <span style=color:#e6db74>&#34;)\n&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ret</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>_EAGAIN</span> {
</span></span><span style=display:flex><span>			println(<span style=color:#e6db74>&#34;runtime: may need to increase max user processes (ulimit -u)&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;newosproc&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>clone函数最后一个实参是我们熟悉的mstart函数,clone后的子线程将会执行它,而父线程将直接返回</p><blockquote><p>这个clone函数位于<code>src/runtime/sys_linux_amd64.s</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>clone</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Linux系统调用约定，这四个参数需要分别放入rdi， rsi，rdx和r10寄存器中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>flags</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>DI</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>stk</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>SI</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>DX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>R10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Copy mp, gp, fn off parent stack for use by child.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Careful: Linux system call clobbers CX and R11.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Linux系统调用会污染CX和R11; 所以我们参数不放在那里面
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>mp</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>R8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>gp</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>R9</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>fn</span><span style=color:#f92672>+</span><span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>R12</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>SYS_clone</span>, <span style=color:#a6e22e>AX</span> <span style=color:#75715e>// 系统调用了; 返回值放入AX寄存器里面.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>SYSCALL</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// In parent, return.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>    <span style=color:#75715e>// 如果返回值是0,证明是子进程返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>JEQ</span>	<span style=color:#ae81ff>3</span>(<span style=color:#a6e22e>PC</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>ret</span><span style=color:#f92672>+</span><span style=color:#ae81ff>40</span>(<span style=color:#a6e22e>FP</span>) <span style=color:#75715e>// 父进程返回,返回到父进程的AX不等于0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>RET</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// In child, on new stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>SI</span>, <span style=color:#a6e22e>SP</span>   <span style=color:#75715e>// sp = stk+8(FP); 就是设置子线程的栈顶;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// If g or m are nil, skip Go-related setup.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#a6e22e>R8</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>    <span style=color:#75715e>// m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>JEQ</span>	<span style=color:#a6e22e>nog</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CMPQ</span>	<span style=color:#a6e22e>R9</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>    <span style=color:#75715e>// g
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>JEQ</span>	<span style=color:#a6e22e>nog</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Initialize m-&gt;procid to Linux tid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>SYS_gettid</span>, <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SYSCALL</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>m_procid</span>(<span style=color:#a6e22e>R8</span>) <span style=color:#75715e>// 设置m.proc_id = sys_gettid()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Set FS to point at m-&gt;tls.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>LEAQ</span>	<span style=color:#a6e22e>m_tls</span>(<span style=color:#a6e22e>R8</span>), <span style=color:#a6e22e>DI</span>  <span style=color:#75715e>// 不取引用,所以是DI=&amp;m.tls[0];把m.tls[0]地址给DI寄存器.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>settls</span>(<span style=color:#a6e22e>SB</span>) <span style=color:#75715e>// FS寄存器里的值:就是m.tls[0]的地址.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// In child, set up new stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>get_tls</span>(<span style=color:#a6e22e>CX</span>) <span style=color:#75715e>// CX = &amp;m.tls[0]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>R8</span>, <span style=color:#a6e22e>g_m</span>(<span style=color:#a6e22e>R9</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>R9</span>, <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>CX</span>) <span style=color:#75715e>// gp+24(FP) == R9; g(CX)---&gt; *CX; m.tls[0]=g0;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>stackcheck</span>(<span style=color:#a6e22e>SB</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>nog</span>:
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Call fn
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>R12</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// It shouldn&#39;t return. If it does, exit that thread.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>111</span>, <span style=color:#a6e22e>DI</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#a6e22e>SYS_exit</span>, <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SYSCALL</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>JMP</span>	<span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>(<span style=color:#a6e22e>PC</span>)	<span style=color:#75715e>// keep exiting
</span></span></span></code></pre></div></blockquote></blockquote><blockquote><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//   list /tmp/kubernets/clone_test/main.go:1
</span></span></span><span style=display:flex><span><span style=color:#75715e>//   list /usr/lib/golang/src/runtime/sys_linux_amd64.s:540
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// gdb调试自定义函数
</span></span></span><span style=display:flex><span><span style=color:#75715e>// define zxc
</span></span></span><span style=display:flex><span><span style=color:#75715e>// info threads
</span></span></span><span style=display:flex><span><span style=color:#75715e>// info register rbp rsp pc
</span></span></span><span style=display:flex><span><span style=color:#75715e>// end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>New</span> <span style=color:#a6e22e>LWP</span> <span style=color:#ae81ff>32548</span>]
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>Switching</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>LWP</span> <span style=color:#ae81ff>32548</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Breakpoint</span> <span style=color:#ae81ff>3</span>, <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>clone</span> () <span style=color:#a6e22e>at</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>lib</span><span style=color:#f92672>/</span><span style=color:#a6e22e>golang</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>runtime</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sys_linux_amd64</span>.<span style=color:#a6e22e>s</span>:<span style=color:#ae81ff>562</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//这一行的确是没必要,clone完后,系统会把子线程的sp寄存器设置为传入参数stk(m.stack.hi)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>562</span>		<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>SI</span>, <span style=color:#a6e22e>SP</span> 
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>gdb</span>) <span style=color:#a6e22e>zxc</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Id</span>   <span style=color:#a6e22e>Target</span> <span style=color:#a6e22e>Id</span>         <span style=color:#a6e22e>Frame</span>
</span></span><span style=display:flex><span><span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>    <span style=color:#a6e22e>LWP</span> <span style=color:#ae81ff>32548</span> <span style=color:#e6db74>&#34;test&#34;</span>  <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>clone</span> () <span style=color:#a6e22e>at</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>lib</span><span style=color:#f92672>/</span><span style=color:#a6e22e>golang</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>runtime</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sys_linux_amd64</span>.<span style=color:#a6e22e>s</span>:<span style=color:#ae81ff>562</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span>    <span style=color:#a6e22e>LWP</span> <span style=color:#ae81ff>32547</span> <span style=color:#e6db74>&#34;test&#34;</span>  <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>clone</span> () <span style=color:#a6e22e>at</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>usr</span><span style=color:#f92672>/</span><span style=color:#a6e22e>lib</span><span style=color:#f92672>/</span><span style=color:#a6e22e>golang</span><span style=color:#f92672>/</span><span style=color:#a6e22e>src</span><span style=color:#f92672>/</span><span style=color:#a6e22e>runtime</span><span style=color:#f92672>/</span><span style=color:#a6e22e>sys_linux_amd64</span>.<span style=color:#a6e22e>s</span>:<span style=color:#ae81ff>556</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rbp</span>            <span style=color:#ae81ff>0x7fffffffe3b0</span>	<span style=color:#ae81ff>0x7fffffffe3b0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rsp</span>            <span style=color:#ae81ff>0xc000044000</span>	<span style=color:#ae81ff>0xc000044000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pc</span>             <span style=color:#ae81ff>0x455568</span>	<span style=color:#ae81ff>0x455568</span> &lt;<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>clone</span><span style=color:#f92672>+</span><span style=color:#ae81ff>56</span>&gt;
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>gdb</span>) <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>sp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sp</span>             <span style=color:#ae81ff>0xc000044000</span>	<span style=color:#ae81ff>0xc000044000</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>gdb</span>) <span style=color:#a6e22e>step</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>565</span>		<span style=color:#a6e22e>CMPQ</span>	<span style=color:#a6e22e>R8</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>    <span style=color:#75715e>// m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>(<span style=color:#a6e22e>gdb</span>) <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>sp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sp</span>             <span style=color:#ae81ff>0xc000044000</span>	<span style=color:#ae81ff>0xc000044000</span>
</span></span></code></pre></div></blockquote></blockquote><hr><h3 id=notewakeup唤醒m>notewakeup唤醒m
<a class=anchor href=#notewakeup%e5%94%a4%e9%86%92m>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>notewakeup</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>note</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Loaduintptr</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Casuintptr</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>locked</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Successfully set waitm to locked.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// What was it before?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>switch</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:  <span style=color:#75715e>// 我们从上面知道 v == note.key; note.key == M结构体的指针; 如果是0,那么这个note是无效的,不需要唤醒.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// Nothing was waiting. Done.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>locked</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Two notewakeups! Not allowed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;notewakeup - double wakeup&#34;</span>) <span style=color:#75715e>// 不能调用这个函数两次, locked的值是1,唤醒一次,这个note.key就变成1了,下次再调用就报错.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Must be the waiting m. Wake it up.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>semawakeup</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>v</span>))) <span style=color:#75715e>//从这个semawakeup(mp *m)需要的参数,可以知道note.key字段是一个M的指针.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=附录>附录
<a class=anchor href=#%e9%99%84%e5%bd%95>#</a></h2><p><a href=https://linux.die.net/man/2/clone>clone系统调用</a></p><p>所以这里必须为子线程指定其使用的栈，否则父子线程会共享同一个栈从而造成混乱，从上面的newosproc函数可以看出，新线程使用的栈为m.g0.stack.lo～m.g0.stack.hi这段内存，而这段内存是newm函数在创建m结构体对象时从进程的堆上分配而来的。</p><ul><li>TODO</li><li>删除的时候可以连着删除<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20200912155441.png alt=20200912155441></li></ul></li></ul><p>1000000个数,白天只查,晚上更新</p><p>一个无序的数组长度为1001 ，数组内的元素值在[1,1000]间，只用基本数据结构找出1001中唯一重复的元素 &mdash; （不能用map）</p><p>将IPv4（192.168.1.1）转换成longl诶行</p><p>一个程序 接收1亿个数 最后返回前100个最大的数</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#goroutine被动调度>goroutine被动调度</a><ul><li><a href=#被动进入睡眠>被动进入睡眠</a><ul><li><a href=#gdb调试前准备>gdb调试前准备</a></li><li><a href=#runtime_semacquire>runtime_Semacquire</a></li><li><a href=#sync_runtime_semacquire>sync_runtime_Semacquire</a></li><li><a href=#gopark>gopark</a></li><li><a href=#park_m>park_m</a></li></ul></li><li><a href=#唤醒睡眠中的goroutine>唤醒睡眠中的goroutine</a><ul><li><a href=#runtime_semrelease>runtime_Semrelease</a></li><li><a href=#readywithtime>readyWithTime</a></li><li><a href=#goready>goready</a></li><li><a href=#runqput>runqput</a></li><li><a href=#wakep>wakep</a></li></ul></li><li><a href=#分析wakep>分析wakep</a><ul><li><a href=#startm>startm</a></li><li><a href=#mget从全局空闲m队列获取m>mget从全局空闲M队列获取m</a></li><li><a href=#newm创建新的线程与m>newm创建新的线程与m</a></li><li><a href=#notewakeup唤醒m>notewakeup唤醒m</a></li></ul></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></div></aside></main></body></html>