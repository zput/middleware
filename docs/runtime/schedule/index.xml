<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>调度 on go调度源码分析</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/</link><description>Recent content in 调度 on go调度源码分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Tue, 23 Jun 2020 20:50:00 +0000</lastBuildDate><atom:link href="https://zput.github.io/go-goroutine/docs/runtime/schedule/index.xml" rel="self" type="application/rss+xml"/><item><title>初始化</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/</link><pubDate>Mon, 20 Jan 2020 10:03:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/</guid><description>进入main函数前的初始化 # 我们首先来gdb调试一下这个程序
// main.go package main import &amp;#34;fmt&amp;#34; // the function&amp;#39;s body is empty func add(x, y int64) int64 func main() { gg:=add(2, 3) fmt.Println(gg) } // add_amd.s TEXT ·add(SB),$0-24 MOVQ x+0(FP), BX MOVQ y+8(FP), BP ADDQ BP, BX MOVQ BX, ret+16(FP) RET 编译一下源代码: go build -gcflags &amp;quot;-N -l&amp;quot; -o test ..
程序加载到内存入口 # Expand ↕ (gdb) info files Symbols from &amp;#34;/tmp/kubernets/test&amp;#34;. Local exec file: `/tmp/kubernets/test&amp;#39;, file type elf64-x86-64.</description></item><item><title>退出</title><link>https://zput.github.io/go-goroutine/docs/runtime/schedule/3_exit_goroutine/</link><pubDate>Mon, 10 Feb 2020 10:09:00 +0000</pubDate><guid>https://zput.github.io/go-goroutine/docs/runtime/schedule/3_exit_goroutine/</guid><description>goroutine退出过程 # goroutine退出,即执行完callee代码后，返回到caller中去，前面一节我们看到，编译器自己把goexit()的地址设置为了caller的pc保存到栈上方,所以退出后，会执行goexit()函数,但是main goroutine比较特殊，这个groutine运行的代码 main函数直接调用了操作系统exit()这个API退出,没有机会返回到caller层.
main goroutine的退出 # 在上节中我们看到程序执行到了 mian函数
// The main goroutine. func main() { g := getg() //... //main包 init函数，递归的调用import包中定义的init函数 fn := main_init // make an indirect call, as the linker doesn&amp;#39;t know the address of the main package when laying down the runtime fn() //... //调用main.main函数(用户定义的main函数):进行间接调用是因为链接器在放置运行时不知道主包的地址 fn = main_main // make an indirect call, as the linker doesn&amp;#39;t know the address of the main package when laying down the runtime fn() //.</description></item></channel></rss>