<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="golang垃圾回收 # golang垃圾回收 理论 About GC 三色 新分配对象的颜色 写屏障 写屏障的步骤推导 插入写屏障 删除写屏障 混合写屏障 其他的变种 golang实现 扩展 mutator? FQA 谈一谈golang的gc. 二：为什么清扫阶段不需要屏障了呢？ 三：golang的heap结构 四: 工作队列相关的问题：并发标记的分工问题？写屏障记录集的竞争问题？ 五： CUP utilization TODO: 并发GC如何缓解内存分配压力？ 附录 内存分配器 heapArena span archive 202104-conclusion what,why,how 理论 # About GC # what: # gc主要是释放那些不再需要的分配在堆（heap）上的数据 why: # 降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。 how: # 一般判断对象是否存活是使用：是把可达性近视的认为存活性.
可把栈（stack），数据段（data segment? bss?）的数据对象作为root Mark-Sweep.
STW(stop the world) 三色标记法。
黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色： conflict:
当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的) 强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态. 读写屏障。
读屏障：非移动式垃圾回收器中，天然不需要读屏障。 写屏障：会在写操作中插入指令，把数据对象的修改通知到垃圾回收器。 插入写屏障： writePointer(slot, ptr): shade(ptr) //shade函数尝试改变指针的颜色-->改变ptr的颜色 *slot = ptr 删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。 writePointer(slot, ptr) shade(*slot) //shade函数尝试改变指针的颜色-->改变(*slot)的颜色--->注意这个是*slot,slot保存着它原先的保存的地址。 *slot = ptr conflict: 只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，代价太大。为了改善这个问题，改为忽略协程栈上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。 混合写屏障：将被覆盖的对象(老对象)标记成灰色并在当前栈没有扫描时将新对象也标记成灰色。 writePointer(slot, ptr): shade(*slot) //将老对象标记为灰色。 if current stack is grey: // The insertion part of the barrier is necessary while the calling goroutine's stack is grey."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="垃圾回收"><meta property="og:description" content="golang垃圾回收 # golang垃圾回收 理论 About GC 三色 新分配对象的颜色 写屏障 写屏障的步骤推导 插入写屏障 删除写屏障 混合写屏障 其他的变种 golang实现 扩展 mutator? FQA 谈一谈golang的gc. 二：为什么清扫阶段不需要屏障了呢？ 三：golang的heap结构 四: 工作队列相关的问题：并发标记的分工问题？写屏障记录集的竞争问题？ 五： CUP utilization TODO: 并发GC如何缓解内存分配压力？ 附录 内存分配器 heapArena span archive 202104-conclusion what,why,how 理论 # About GC # what: # gc主要是释放那些不再需要的分配在堆（heap）上的数据 why: # 降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。 how: # 一般判断对象是否存活是使用：是把可达性近视的认为存活性.
可把栈（stack），数据段（data segment? bss?）的数据对象作为root Mark-Sweep.
STW(stop the world) 三色标记法。
黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。 灰色：基于当前节点展开的追踪还未完成。 白色： conflict:
当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的) 强三色：黑色对象只能引用灰色对象。 弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态. 读写屏障。
读屏障：非移动式垃圾回收器中，天然不需要读屏障。 写屏障：会在写操作中插入指令，把数据对象的修改通知到垃圾回收器。 插入写屏障： writePointer(slot, ptr): shade(ptr) //shade函数尝试改变指针的颜色-->改变ptr的颜色 *slot = ptr 删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。 writePointer(slot, ptr) shade(*slot) //shade函数尝试改变指针的颜色-->改变(*slot)的颜色--->注意这个是*slot,slot保存着它原先的保存的地址。 *slot = ptr conflict: 只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，代价太大。为了改善这个问题，改为忽略协程栈上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。 混合写屏障：将被覆盖的对象(老对象)标记成灰色并在当前栈没有扫描时将新对象也标记成灰色。 writePointer(slot, ptr): shade(*slot) //将老对象标记为灰色。 if current stack is grey: // The insertion part of the barrier is necessary while the calling goroutine's stack is grey."><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/golang_gc/"><meta property="article:section" content="docs"><title>垃圾回收 | go调度源码分析</title><link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png type=image/x-icon><link rel=stylesheet href=/go-goroutine/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script>
<script defer src=/go-goroutine/en.search.min.75f3025a21511955ad10f181cae208dd296ce24ee2a06def487a11decfa675f1.js integrity="sha256-dfMCWiFRGVWtEPGByuII3Sls4k7ioG3vSHoR3s+mdfE=" crossorigin=anonymous></script>
<script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/ class=active>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-99f41010918d678e89a7af90330cabe1 class=toggle>
<label for=section-99f41010918d678e89a7af90330cabe1 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>执行太久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>系统调用抢占</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script>
<script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu></label>
<strong>垃圾回收</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#golang垃圾回收>golang垃圾回收</a><ul><li><a href=#理论>理论</a><ul><li><a href=#about-gc>About GC</a></li><li><a href=#what>what:</a></li><li><a href=#why>why:</a></li><li><a href=#how>how:</a></li><li><a href=#三色>三色</a></li><li><a href=#新分配对象的颜色>新分配对象的颜色</a></li><li><a href=#写屏障>写屏障</a></li></ul></li><li><a href=#golang实现>golang实现</a></li><li><a href=#扩展>扩展</a><ul><li><a href=#mutator>mutator?</a></li><li><a href=#fqa>FQA</a></li></ul></li><li><a href=#附录>附录</a><ul><li><a href=#内存分配器>内存分配器</a></li></ul></li><li><a href=#archive>archive</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=golang垃圾回收>golang垃圾回收
<a class=anchor href=#golang%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6>#</a></h1><ul><li><a href=/go-goroutine/#golang%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6>golang垃圾回收</a><ul><li><a href=/go-goroutine/#%e7%90%86%e8%ae%ba>理论</a><ul><li><a href=/go-goroutine/#about-gc>About GC</a></li><li><a href=/go-goroutine/#%e4%b8%89%e8%89%b2>三色</a></li><li><a href=/go-goroutine/#%e6%96%b0%e5%88%86%e9%85%8d%e5%af%b9%e8%b1%a1%e7%9a%84%e9%a2%9c%e8%89%b2>新分配对象的颜色</a></li><li><a href=/go-goroutine/#%e5%86%99%e5%b1%8f%e9%9a%9c>写屏障</a><ul><li><a href=/go-goroutine/#%e5%86%99%e5%b1%8f%e9%9a%9c%e7%9a%84%e6%ad%a5%e9%aa%a4%e6%8e%a8%e5%af%bc>写屏障的步骤推导</a><ul><li><a href=/go-goroutine/#%e6%8f%92%e5%85%a5%e5%86%99%e5%b1%8f%e9%9a%9c>插入写屏障</a></li><li><a href=/go-goroutine/#%e5%88%a0%e9%99%a4%e5%86%99%e5%b1%8f%e9%9a%9c>删除写屏障</a></li><li><a href=/go-goroutine/#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c>混合写屏障</a></li><li><a href=/go-goroutine/#%e5%85%b6%e4%bb%96%e7%9a%84%e5%8f%98%e7%a7%8dhttpsgithubcomgolangproposalblobmasterdesign17503-eliminate-rescanmdalternative-barrier-approaches>其他的变种</a></li></ul></li></ul></li></ul></li><li><a href=/go-goroutine/#golang%e5%ae%9e%e7%8e%b0>golang实现</a></li><li><a href=/go-goroutine/#%e6%89%a9%e5%b1%95>扩展</a><ul><li><a href=/go-goroutine/#mutator>mutator?</a></li><li><a href=/go-goroutine/#fqa>FQA</a><ul><li><a href=/go-goroutine/#%e8%b0%88%e4%b8%80%e8%b0%88golang%e7%9a%84gc>谈一谈golang的gc.</a></li><li><a href=/go-goroutine/#%e4%ba%8c%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b8%85%e6%89%ab%e9%98%b6%e6%ae%b5%e4%b8%8d%e9%9c%80%e8%a6%81%e5%b1%8f%e9%9a%9c%e4%ba%86%e5%91%a2>二：为什么清扫阶段不需要屏障了呢？</a></li><li><a href=/go-goroutine/#%e4%b8%89golang%e7%9a%84heap%e7%bb%93%e6%9e%84>三：golang的heap结构</a></li><li><a href=/go-goroutine/#%e5%9b%9b-%e5%b7%a5%e4%bd%9c%e9%98%9f%e5%88%97%e7%9b%b8%e5%85%b3%e7%9a%84%e9%97%ae%e9%a2%98%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e7%9a%84%e5%88%86%e5%b7%a5%e9%97%ae%e9%a2%98%e5%86%99%e5%b1%8f%e9%9a%9c%e8%ae%b0%e5%bd%95%e9%9b%86%e7%9a%84%e7%ab%9e%e4%ba%89%e9%97%ae%e9%a2%98>四: <strong>工作队列</strong>相关的问题：并发标记的分工问题？写屏障记录集的竞争问题？</a></li><li><a href=/go-goroutine/#%e4%ba%94-cup-utilization>五： CUP utilization</a></li><li><a href=/go-goroutine/#todo-%e5%b9%b6%e5%8f%91gc%e5%a6%82%e4%bd%95%e7%bc%93%e8%a7%a3%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%8e%8b%e5%8a%9b>TODO: 并发GC如何缓解内存分配压力？</a></li></ul></li></ul></li><li><a href=/go-goroutine/#%e9%99%84%e5%bd%95>附录</a><ul><li><a href=/go-goroutine/#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8>内存分配器</a><ul><li><a href=/go-goroutine/#heaparena>heapArena</a></li><li><a href=/go-goroutine/#span>span</a></li></ul></li></ul></li><li><a href=/go-goroutine/#archive>archive</a></li></ul></li></ul><hr><ul><li>202104-conclusion<ul><li>what,why,how</li></ul></li></ul><hr><h2 id=理论>理论
<a class=anchor href=#%e7%90%86%e8%ae%ba>#</a></h2><h3 id=about-gc>About GC
<a class=anchor href=#about-gc>#</a></h3><blockquote><h3 id=what>what:
<a class=anchor href=#what>#</a></h3></blockquote><ul><li>gc主要是释放那些不再需要的分配在堆（heap）上的数据</li></ul><blockquote><h3 id=why>why:
<a class=anchor href=#why>#</a></h3></blockquote><ul><li>降低人的心智负担，从堆（heap）中申请的内存，不需要手动的释放。</li></ul><blockquote><h3 id=how>how:
<a class=anchor href=#how>#</a></h3></blockquote><ul><li><p>一般判断对象是否存活是使用：是把可达性近视的认为存活性.</p><ul><li>可把栈（stack），数据段（data segment? bss?）的数据对象作为root</li></ul></li><li><p>Mark-Sweep.</p><ul><li>STW(stop the world)</li></ul></li><li><p>三色标记法。</p><ul><li>黑色：当基于当前节点的追踪任务完成后，表示为存活数据，后续无需再追踪。</li><li>灰色：基于当前节点展开的追踪还未完成。</li><li>白色：</li></ul></li><li><p>conflict:</p><ul><li>当gc使用三色标记法与用户程序并发执行的时候，可能让黑色对象重新引用了白色对象，且无其他灰色对象引用了这个白色对象。导致白色对象错误回收。(用户程序和垃圾收集器可以在交替工作的)<ul><li>强三色：黑色对象只能引用灰色对象。</li><li>弱三色：所有被黑色对象引用的白色对象都处于灰色保护状态.</li></ul></li></ul></li><li><p>读写屏障。</p><ul><li>读屏障：非移动式垃圾回收器中，天然不需要读屏障。</li><li>写屏障：会在写操作中插入指令，把数据对象的修改通知到垃圾回收器。<ul><li>插入写屏障：</li></ul><pre tabindex=0><code>writePointer(slot, ptr):
  	shade(ptr) //shade函数尝试改变指针的颜色--&gt;改变ptr的颜色
   	*slot = ptr
</code></pre><ul><li>删除写屏障： 会在老对象的引用被删除时，将白色的老对象涂成灰色。</li></ul><pre tabindex=0><code>writePointer(slot, ptr)
	shade(*slot) //shade函数尝试改变指针的颜色--&gt;改变(*slot)的颜色---&gt;注意这个是*slot,slot保存着它原先的保存的地址。
	*slot = ptr
</code></pre><ul><li>conflict: 只有插入写屏障，但是这需要对所有堆、栈的写操作都开启写屏障，代价太大。为了改善这个问题，改为<strong>忽略协程栈</strong>上的写屏障，只在标记结束阶段重新扫描那些被激活的栈帧。但是Go语言通常会有大量活跃的协程，这就导致第二次STW时重新扫描协程栈的时间太长。<ul><li>混合写屏障：将被覆盖的对象(老对象)标记成灰色并在当前栈没有扫描时将新对象也标记成灰色。</li></ul><pre tabindex=0><code> writePointer(slot, ptr):
  shade(*slot) //将老对象标记为灰色。
  if current stack is grey: // The insertion part of the barrier is necessary while the calling goroutine&#39;s stack is grey.
      shade(ptr)
  *slot = ptr
</code></pre><ul><li>既可<strong>忽略当前栈帧的写屏障</strong>。(不管是插入写屏障，还是删除写屏障.)<ul><li>这里模拟很容易，黑色关联白色，且没有其他灰色关联这个黑色；就会出现hiding object。<ul><li>模拟heap上触发<strong>删除写屏障</strong>。&mdash;》所以stack上一个black object关联heap上面的white object；这时候heap上的其他颜色object断开与它的连接。</li><li>模拟heap上触发<strong>插入写屏障</strong>。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/gc.png alt=gc></li></ul></li></ul></li></ul></li><li>又不需要在第二次STW的时，重新扫描所有活跃G的栈帧。</li></ul></li></ul></li></ul></li></ul><h3 id=三色>三色
<a class=anchor href=#%e4%b8%89%e8%89%b2>#</a></h3><h3 id=新分配对象的颜色>新分配对象的颜色
<a class=anchor href=#%e6%96%b0%e5%88%86%e9%85%8d%e5%af%b9%e8%b1%a1%e7%9a%84%e9%a2%9c%e8%89%b2>#</a></h3><p>黑色赋值器：已经由回收器扫描过，不会再次对其进行扫描。
灰色赋值器：尚未被回收器扫描过，或尽管已经扫描过但仍需要重新扫描。</p><p>如果新分配的对象为黑色或者灰色，则赋值器直接将其视为无需回收的对象，写入堆中；
如果新分配的对象为白色，则可以避免无意义的新对象保留到下一个垃圾回收的周期。</p><p>由于黑色赋值器由于已经被回收器扫描过， 不会再对其进行任何扫描，一旦其分配新的白色对象 则意味着会导致错误的回收。</p><h3 id=写屏障>写屏障
<a class=anchor href=#%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h3><p>背景：如果对栈和堆都执行写屏障(不管是插入写屏障，还是删除写屏障)，那么按照三色原则，插入写屏障使它不满足强三色不变式，删除写屏障使它一定不满足弱三色不变式。两种写屏障都不会错误回收。<strong>但是基于性能考虑，栈上不触发写屏障。</strong></p><ul><li><code>writePointer(slot, ptr):</code><ul><li><code>*slot</code>可能是null。</li><li><code>*slot</code>可能是它以前关联的那个值，现在要断开。</li><li><code>ptr</code>是现在将要关联的这个值。</li></ul></li></ul><p>引申的插入写屏障，删除写屏障</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>):  <span style=color:#75715e>// 插入写屏障
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变ptr的颜色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>)     <span style=color:#75715e>// 删除写屏障
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变(*slot)的颜色---&gt;注意这个是*slot,slot保存着它原先的保存的地址。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><h4 id=写屏障的步骤推导>写屏障的步骤推导
<a class=anchor href=#%e5%86%99%e5%b1%8f%e9%9a%9c%e7%9a%84%e6%ad%a5%e9%aa%a4%e6%8e%a8%e5%af%bc>#</a></h4><pre tabindex=0><code>   |........标记清扫阶段...........|
STW begin                     STW end
</code></pre><ul><li><p>分类步骤:</p><ul><li>STW扫描的位置点: 是在<strong>开始扫描</strong>还是在<strong>最后来一次扫描</strong>?</li><li>STW扫描可以按照每个goroutine的方式来一个个扫描? 不必一次暂停所有goroutine栈<ul><li>STW goroutine栈扫描: 栈上对象都变成黑色,一些堆对象(与栈对联直连)为灰色,其他的为白色.// TODO picture</li></ul></li><li>创建的新对象是黑色还是白色?</li></ul></li><li><p>防止类型就是:</p><ul><li>heap_black_object -> heap_white_object</li><li>stack_black_object -> heap_white_object</li></ul></li></ul><hr><h5 id=插入写屏障>插入写屏障
<a class=anchor href=#%e6%8f%92%e5%85%a5%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h5><table><thead><tr><th>开始步骤</th><th>步骤</th><th>\</th><th>新生成对象的颜色</th></tr></thead><tbody><tr><td>STW全栈扫描</td><td>堆上使用插入写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr><tr><td>STW goroutine栈扫描</td><td>堆上使用插入写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr><tr><td>堆上使用插入写屏障</td><td>STW全栈扫描</td><td>\</td><td>新生成的对象黑白都可</td></tr><tr><td>堆上使用插入写屏障</td><td>STW goroutine栈扫描</td><td>\</td><td>新生成的对象黑白都可</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>/**************<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  STW全栈扫描
</span></span><span style=display:flex><span>  堆上使用插入写屏障 | <span style=color:#f92672>[</span>创建新对象为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  STW goroutine栈扫描
</span></span><span style=display:flex><span>  堆上使用插入写屏障 | <span style=color:#f92672>[</span>创建新对象为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  堆上使用插入写屏障 | <span style=color:#f92672>[</span>创建新对象为可以为白色,也可以为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  STW全栈扫描
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>4<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  堆上使用插入写屏障 | <span style=color:#f92672>[</span>创建新对象为可以为白色,也可以为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  STW goroutine栈扫描
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>(1)(2)不行,如图:
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210404172432.png alt=20210404172432></p><p>(3)可以,1.5到1.7就是使用的这种方式
(4)没必要了,都是最后STW,重新扫描一次灰色的goroutine栈</p><h5 id=删除写屏障>删除写屏障
<a class=anchor href=#%e5%88%a0%e9%99%a4%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h5><ul><li>删除写屏障<ul><li>起始快照整栈跨找，扫黑，使得整个堆上的在用对象都处于灰色保护；<ul><li>整栈扫黑，那么在用的堆上的对象是一定处于灰色堆对象的保护下的，之后配合堆对象删除写屏障就能保证在用对象不丢失。</li></ul></li><li>加入插入写屏障的逻辑，C 指向 D 的时候，把 D 置灰，这样扫描也没问题。这样就能去掉起始 STW 扫描，从而可以并发，一个一个栈扫描。</li></ul></li></ul><table><thead><tr><th>开始步骤</th><th>步骤</th><th>\</th><th>新生成对象的颜色</th></tr></thead><tbody><tr><td>STW全栈扫描</td><td>堆上使用删除写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr><tr><td>STW goroutine栈扫描</td><td>堆上使用删除写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr><tr><td>堆上使用删除写屏障</td><td>STW全栈扫描</td><td>\</td><td>新生成的对象黑白都可</td></tr><tr><td>堆上使用删除写屏障</td><td>STW goroutine栈扫描</td><td>\</td><td>新生成的对象黑白都可</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>/**************<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  STW全栈扫描
</span></span><span style=display:flex><span>  堆上使用删除写屏障 | <span style=color:#f92672>[</span>创建新对象为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  STW goroutine栈扫描
</span></span><span style=display:flex><span>  堆上使用删除写屏障 | <span style=color:#f92672>[</span>创建新对象为黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  堆上使用删除写屏障 | <span style=color:#f92672>[</span>创建新对象为可以为白色/黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  STW全栈扫描
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/**************<span style=color:#f92672>(</span>4<span style=color:#f92672>)</span>**************/ 
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  堆上使用删除写屏障 | <span style=color:#f92672>[</span>创建新对象为可以为白色/黑色<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  STW goroutine栈扫描
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>(1)可以
(2)不行,如图:
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210404172300.png alt=20210404172300></p><p>(3)(4)的话,因为是最后进行栈重新扫描,可以知道不会出现<code>stack_black_object -> heap_white_object</code>这种情况.
如图:
// TODO</p><h5 id=混合写屏障>混合写屏障
<a class=anchor href=#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c>#</a></h5><ul><li>hybrid write barrier</li></ul><blockquote><p>由前面的删除写屏障(2),我们只要加上插入写屏障就能避免出现隐藏白色对象这种情况.</p><blockquote><p>这个也是<code>if current stack is grey:</code>的由来.</p></blockquote></blockquote><table><thead><tr><th>步骤</th><th>步骤</th><th>\</th><th>新生成对象的颜色</th></tr></thead><tbody><tr><td>STW goroutine栈扫描(要么全黑要么全白)</td><td>堆上使用删除写屏障+堆上使用插入写屏障</td><td>\</td><td>新生成的对象都是黑色</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>current</span> <span style=color:#a6e22e>stack</span> <span style=color:#a6e22e>is</span> <span style=color:#a6e22e>grey</span>:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><blockquote><p>The hybrid barrier requires that objects be allocated black (allocate-white is a common policy, but incompatible with this barrier).</p></blockquote><hr><h5 id=其他的变种httpsgithubcomgolangproposalblobmasterdesign17503-eliminate-rescanmdalternative-barrier-approaches><a href=https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md#alternative-barrier-approaches>其他的变种</a>
<a class=anchor href=#%e5%85%b6%e4%bb%96%e7%9a%84%e5%8f%98%e7%a7%8dhttpsgithubcomgolangproposalblobmasterdesign17503-eliminate-rescanmdalternative-barrier-approaches>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>any</span> <span style=color:#a6e22e>stack</span> <span style=color:#a6e22e>is</span> <span style=color:#a6e22e>grey</span>:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><h2 id=golang实现>golang实现
<a class=anchor href=#golang%e5%ae%9e%e7%8e%b0>#</a></h2><p><a href=https://docs.go101.org/std/src/runtime/mbarrier.go.html>https://docs.go101.org/std/src/runtime/mbarrier.go.html</a></p><p>为什么gc也要扫描栈，不是都在堆上面吗？</p><ul><li>因为堆上的地址，可能保存在栈上某个变量里，所以需要扫描。</li></ul><hr><blockquote><ul><li>The hybrid barrier requires that objects be allocated black (allocate-white is a common policy, but incompatible with this barrier). 混合写屏障的时候要求新对象被分配为黑色（这里我猜是所有的对象，栈对象，或者堆对象也好）</li><li>once a stack has been scanned and blackened, it remains black. 一旦栈被扫描（这个的扫描是第一次扫描，查找根对象的时候）和置为黑，那么它一直保持为黑<ul><li>说明栈在第一次扫描的时候就会把栈上对象置为黑色？</li></ul></li><li>In the hybrid barrier, the two shades and the condition work together<ul><li>shade(*slot): 从heap到stack移动白色对象，染为灰色。（尝试如果它试图从heap中解开一个对象的链接，就会对其进行遮挡。）</li><li>shade(ptr): 从stack到一个黑色的heap对象。</li><li>Once a goroutine&rsquo;s stack is black, the shade(ptr) becomes unnecessary. shade(ptr) prevents hiding an object by moving it from the stack to the heap, but this requires first having a pointer hidden on the stack. Immediately after a stack is scanned, it only points to shaded objects, so it&rsquo;s not hiding anything, and the shade(*slot) prevents it from hiding any other pointers on its stack.</li></ul></li><li>一个Goroutine写到另一个Goroutine:</li></ul></blockquote><pre tabindex=0><code>我就是觉得混合写屏障好像也没法 解决重新扫描栈的问题。我举个例子：
现在有 A, B, C三个对象，A(黑色，栈上)，B（灰色，栈上），C（白色，堆上）；
当前引用关系是：
A（黑） -&gt; nil
B（灰） -&gt; C（白）
现在应用程序赋值修改，把A指向C：
A（黑） -&gt; C（白）
B（灰） -&gt; nil
由于A，B是栈上的对象，栈上对象赋值这里可是没有写屏障的；那么岂不是黑色对象指向白色对象了，C会回收了，就悬挂指针了？？？
</code></pre><blockquote><ul><li>Goroutine 栈扫描的过程需要 STW，所以你描述的这种状况是不存在的，<strong>栈上的对象要么全白要么全黑</strong><ul><li>你说的“栈上的对象要么全白，要么全黑“ ，这个只是对一个 goroutine 栈来说的（golang 暂停业务扫描栈也是一个一个来的）。如果场景是 A 在 Goroutine1，B在Goroutine2呢？这种情况就是A是黑色，B是白色或者灰色。这样会不会就有我说的原本那个问题呢？<ul><li><a href=https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md#channel-operations-and-go-statements>The hybrid barrier assumes a goroutine cannot write to another goroutine&rsquo;s stack.(混合写屏障假设一个goroutine,不能写到另一个goroutine的栈)</a></li></ul></li><li>除了从一个Goroutine通过chan发送/生成一个新Goroutine<ul><li>如果两个Goroutine 栈只要有一个是灰色的，那么就会有<code>shade(ptr)</code></li><li>新生成的Goroutine栈都是黑色的（由前面的条件保证）,如果父Goroutine是灰色的，那么需使用<code>shade(ptr)</code></li></ul></li></ul></li></ul></blockquote><p><a href=https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md>https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a></p><hr><h2 id=扩展>扩展
<a class=anchor href=#%e6%89%a9%e5%b1%95>#</a></h2><h3 id=mutator>mutator?
<a class=anchor href=#mutator>#</a></h3><p>“同GC并发执行的用户程序，源码与GC相关书籍中都称其为“mutator”（赋值器）”</p><h3 id=fqa>FQA
<a class=anchor href=#fqa>#</a></h3><h4 id=谈一谈golang的gc>谈一谈golang的gc.
<a class=anchor href=#%e8%b0%88%e4%b8%80%e8%b0%88golang%e7%9a%84gc>#</a></h4><ul><li><p>一：Golang中GC的实现采用的是标记——清扫算法，支持增量与并发式回收。非完全并发操作</p><ul><li>标记清除，不是像原始的，STW（stop the world）, 一个是暂停的时间太长，二个是用户的程序需暂停。它采用的是基于三色标记的混合写屏障。</li><li>增量和并发，一个是横向一个是纵向，gc与mutator交替与运行。所以这里也需要屏障技术。<ul><li>横向：增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；</li><li>纵向：并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；<ul><li>因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性.</li></ul></li></ul></li></ul></li><li><p>使用混合写屏障的原因是缩短gc暂停的时间。</p><ul><li>因为栈上使用写屏障，会导致耗时太多。但是如果栈上不使用写屏障，等到第二次STW重新扫描栈空间，goroutine数目多，需要扫描的stack耗时也多。
忽略协程栈的写屏障;其他的使用删除写屏障，插入写屏障。</li></ul></li><li><p>如果没有任何STW的时间，也就是说垃圾回收程序与用户程序完全并发执行，其代价与实现难度可能都会高于短暂的STW。例如标记——清扫回收器中，若完全抛弃STW，那么垃圾回收开始的消息便很难准确及时地通知到所有线程，可能导致<strong>某些线程</strong>开启<strong>写屏障</strong>的动作有所延迟而无法保障双方执行的正确性。</p></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113105703.png alt=gc></p><h4 id=二为什么清扫阶段不需要屏障了呢>二：为什么清扫阶段不需要屏障了呢？
<a class=anchor href=#%e4%ba%8c%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b8%85%e6%89%ab%e9%98%b6%e6%ae%b5%e4%b8%8d%e9%9c%80%e8%a6%81%e5%b1%8f%e9%9a%9c%e4%ba%86%e5%91%a2>#</a></h4><ul><li>当标记完成了，那么它白色的对象都是不可达的对象，是可以删除的对象，程序不可能再找到已经不可达的对象。所以放心的清除。</li></ul><h4 id=三golang的heap结构>三：golang的heap结构
<a class=anchor href=#%e4%b8%89golang%e7%9a%84heap%e7%bb%93%e6%9e%84>#</a></h4><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113134838.png alt=20210113134838></li><li>参见下面的内存分配器<ul><li><ol start=3><li>Golang中GC的三色标记
-（1）着为灰色对应的操作就是把指针对应的<code>gcmarkBits</code>标记位置为1并<strong>加入工作队列</strong>；
-（2）着为黑色对应的操作就是把指针对应的<code>gcmarkBits</code>标记位置为<code>1</code>。
-（3）白色对象就是那些<code>gcMarkBits</code>中标记为0的对象。</li></ol></li></ul></li></ul><p>知道标记在哪了，那么如果进行分工？</p><h4 id=四-工作队列相关的问题并发标记的分工问题写屏障记录集的竞争问题>四: <strong>工作队列</strong>相关的问题：并发标记的分工问题？写屏障记录集的竞争问题？
<a class=anchor href=#%e5%9b%9b-%e5%b7%a5%e4%bd%9c%e9%98%9f%e5%88%97%e7%9b%b8%e5%85%b3%e7%9a%84%e9%97%ae%e9%a2%98%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e7%9a%84%e5%88%86%e5%b7%a5%e9%97%ae%e9%a2%98%e5%86%99%e5%b1%8f%e9%9a%9c%e8%ae%b0%e5%bd%95%e9%9b%86%e7%9a%84%e7%ab%9e%e4%ba%89%e9%97%ae%e9%a2%98>#</a></h4><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210121134453.png alt=20210121134453></p><blockquote><p>这里的竞争问题，我怀疑是： 一个是gc从root Object到一直遍历，打标记(从上到下)，同时另一个用户程序也在更新Object的关联（比如从从一个灰色到白色节点断开）</p><blockquote><p>其中用户程序的写到每个P中的写屏障缓冲区。</p></blockquote></blockquote><ul><li>前面提到了全局变量work中存储着全局工作队列缓存（work.full），其实每个P都有<strong>一个本地工作队列（p.gcw）和一个写屏障缓冲（p.wbBuf）</strong>。</li><li>p.gcw中有两个workbuf：wbuf1和wbuf2，添加任务时总是从wbuf1添加，wbuf1满了就交换wbuf1和wbuf2，如果还是满的，就把当前wbuf1的工作flush到全局工作缓存中去。</li></ul><p>知道分工了，不可能占用很多CPU进行gc,这样会限制用户程序。</p><h4 id=五-cup-utilization>五： CUP utilization
<a class=anchor href=#%e4%ba%94-cup-utilization>#</a></h4><ul><li>GC默认的CPU目标使用率为25%，在GC执行的初始化阶段，会根据当前CPU核数乘以CPU目标使用率来计算需要启动的<code>mark worker</code>数量。</li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113134856.png alt=20210113134856></li></ul><h4 id=todo-并发gc如何缓解内存分配压力>TODO: 并发GC如何缓解内存分配压力？
<a class=anchor href=#todo-%e5%b9%b6%e5%8f%91gc%e5%a6%82%e4%bd%95%e7%bc%93%e8%a7%a3%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%8e%8b%e5%8a%9b>#</a></h4><ul><li>借贷偿还机制。也可以偷。</li></ul><h2 id=附录>附录
<a class=anchor href=#%e9%99%84%e5%bd%95>#</a></h2><h3 id=内存分配器>内存分配器
<a class=anchor href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8>#</a></h3><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210408201124.png alt=20210408201124></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/gc_heap.png alt=gc_heap></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:notinheap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mheap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>//...    
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// arenas is the heap arena map. It points to the metadata for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the heap for every arena frame of the entire usable virtual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// address space.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Use arenaIndex to compute indexes into this array.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// For regions of the address space that are not backed by the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Go heap, the arena map contains nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Modifications are protected by mheap_.lock. Reads can be
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// performed without locking; however, a given entry can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// transition from nil to non-nil at any time when the lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// isn&#39;t held. (Entries never transitions back to nil.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// In general, this is a two-level mapping consisting of an L1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// map and possibly many L2 maps. This saves space when there
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// are a huge number of arena frames. However, on many
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// platforms (even 64-bit), arenaL1Bits is 0, making this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// effectively a single-level map. In this case, arenas[0]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// will never be nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>arenas</span> [<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL1Bits</span>]<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL2Bits</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>heapArena</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//A heapArena stores metadata for a heap arena.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 每一个heapArena管理一个heap arena.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>heapArena</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bitmap</span> [<span style=color:#a6e22e>heapArenaBitmapBytes</span>]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>spans</span> [<span style=color:#a6e22e>pagesPerArena</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pageInUse</span> [<span style=color:#a6e22e>pagesPerArena</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pageMarks</span> [<span style=color:#a6e22e>pagesPerArena</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>zeroedBase</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mspan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>startAddr</span> <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 起始地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>npages</span>    <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 页数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>freeindex</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>allocBits</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gcmarkBits</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>allocCache</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//startAddr 和 npages — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#75715e>//freeindex — 扫描页中空闲对象的初始索引；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#75715e>//allocBits 和 gcmarkBits — 分别用于标记内存的占用和回收情况；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#75715e>//allocCache — allocBits 的补码，可以用于快速查找内存中未被使用的内存；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span></code></pre></div><p><a href=https://github.com/golang/go/blob/e7f9e17b7927cad7a93c5785e864799e8d9b4381/src/runtime/mheap.go#L152>mheap</a></p><p><a href=https://github.com/golang/go/blob/e7f9e17b7927cad7a93c5785e864799e8d9b4381/src/runtime/mheap.go#L217>heapArena</a></p><h4 id=heaparena>heapArena
<a class=anchor href=#heaparena>#</a></h4><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210120104547.png alt=20210120104547></p><ul><li>mheap中每个arena对应一个HeapArena，记录arena的元数据信息。HeapArena中有一个<strong>bitmap和一个spans</strong>字段。<ul><li>1.bitmap<ul><li>bitmap中每两个bit对应标记arena中一个指针大小的word，也就是说bitmap中<strong>一个byte</strong>可以标记<strong>arena中连续四个指针大小</strong>的内存。<ul><li>每个word对应的两个bit中，<strong>低位bit用于标记是否为指针</strong>，0为非指针，1为指针；<strong>高位bit用于标记是否要继续扫描</strong>，<code>高位bit为1</code>就代表扫描完当前word并不能完成当前数据对象的扫描。</li></ul></li></ul></li><li>2.spans<ul><li>spans是一个*mspan类型的数组，用于记录当前arena中每一页对应到哪一个mspan。(看这个mspan的结构可以知道，它有startAddr与npages,说明一个mspan管理多个page)</li></ul></li></ul></li></ul><blockquote><p>基于HeapArena记录的元数据信息，我们只要知道一个对象的地址，</p><blockquote><p>就可以根据HeapArena.bitmap信息扫描它内部是否含有指针；
也可以根据对象地址计算出它在哪一页，然后通过HeapArena.spans信息查到该对象存在哪一个mspan中。</p></blockquote></blockquote><h4 id=span>span
<a class=anchor href=#span>#</a></h4><ul><li>而每个span都对应两个位图标记：mspan.allocBits和mspan.gcmarkBits。<ul><li>（1）allocBits中每一位用于标记一个对象存储单元是否已分配。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113202836.png alt=20210113202836></li></ul></li><li>（2）<code>gcmarkBits</code>中每一位用于标记<strong>一个对象是否存活</strong>。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210113202858.png alt=20210113202858></li></ul></li></ul></li></ul><h2 id=archive>archive
<a class=anchor href=#archive>#</a></h2><p><del>堆（heap）上面的都有插入写屏障，不会发生hiding object。</del></p><p>栈上是没有写屏障的，
&lt;堆与栈之间>或者&lt;堆与堆>才会触发写屏障</p><ul><li>一个是插入写屏障<ul><li>破坏第一个条件</li><li>记住插入，&mdash;黑色&mdash;-白色===》 黑色&mdash;-灰色<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>):
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变ptr的颜色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div></li></ul></li></ul><hr><ul><li>一个是删除写屏障<ul><li>破坏第二个条件。</li><li>删除</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>) <span style=color:#75715e>//shade函数尝试改变指针的颜色--&gt;改变slot的颜色---&gt;注意这个是*slot,slot保存着它原先的保存的地址。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><ul><li>disadvantage:<ul><li>which means that many stacks must be re-scanned during STW. The garbage collector first scans all stacks at the beginning of the GC cycle to collect roots.(第一次扫描所有的栈在收集根对象的时候，不能保证在栈后面不会有黑对象引用了白对象)</li></ul></li></ul></li></ul><hr><ul><li>混合写屏障<ul><li>what: 混合写屏障为了<strong>消除栈的重扫</strong>过程.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>writePointer</span>(<span style=color:#a6e22e>slot</span>, <span style=color:#a6e22e>ptr</span>):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shade</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>current</span> <span style=color:#a6e22e>stack</span> <span style=color:#a6e22e>is</span> <span style=color:#a6e22e>grey</span>:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>shade</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>slot</span> = <span style=color:#a6e22e>ptr</span>
</span></span></code></pre></div><ul><li><p>why:</p></li><li><p>how: 通过几种方式来保证弱三色一致性</p><ul><li>STW 扫描一次协程栈(扫一个Goroutine栈就变为黑色) + 创建对象默认黑色<ul><li>开启写屏障期间创建的所有对象默认都是黑色</li></ul></li><li>混合写屏障 + 两Goroutine之间交流</li></ul></li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#golang垃圾回收>golang垃圾回收</a><ul><li><a href=#理论>理论</a><ul><li><a href=#about-gc>About GC</a></li><li><a href=#what>what:</a></li><li><a href=#why>why:</a></li><li><a href=#how>how:</a></li><li><a href=#三色>三色</a></li><li><a href=#新分配对象的颜色>新分配对象的颜色</a></li><li><a href=#写屏障>写屏障</a></li></ul></li><li><a href=#golang实现>golang实现</a></li><li><a href=#扩展>扩展</a><ul><li><a href=#mutator>mutator?</a></li><li><a href=#fqa>FQA</a></li></ul></li><li><a href=#附录>附录</a><ul><li><a href=#内存分配器>内存分配器</a></li></ul></li><li><a href=#archive>archive</a></li></ul></li></ul></nav></div></aside></main></body></html>