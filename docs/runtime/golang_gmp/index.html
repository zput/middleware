<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="golang GMP概念 # what: 是golang内部自己实现的调度器，由’‘G’’,“M”,“P&#34;用来调度goruntine，被称为&#34;GMP模型”。
GMP G:为了调度方便，保存寄存器，栈地址等->对应cpu切换[1.cpu寄存器的值；2.stack地址] M:与系统线程一一对应 P:一些上下文，比如局部P，防止锁，局部P的heap,也能防止加锁的导致的资源损耗。 why:
单进程时代不需要调度器
1.单一的执行流程，计算机只能一个任务一个任务处理。 2.进程阻塞所带来的CPU时间浪费。 多进程/线程时代有了调度器需求
1.解决了阻塞的问题 2.CPU有很大的一部分都被浪费在进程调度 设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。 协程(用户线程)来提高CPU利用率(减少CPU浪费在进程调度上)
为什么。 线程和进程有很多相同的控制权。线程有自己的信号掩码，可以分配CPU时间，可以放入cgroups，可以查询它们使用了哪些资源。所有这些控制都增加了一些功能的开销，而这些功能对于Go程序如何使用goroutine来说是根本不需要的，而且当你的程序中有10万个线程时，它们很快就会增加。 Go调度器可以做出只在它知道内存是一致的点进行调度的决定。 如何进行调度。 一种是N:1，即在一个操作系统线程上运行几个用户空间线程。这样做的好处是上下文切换非常快，但不能利用多核系统的优势。 另一种是1:1，一个执行线程匹配一个OS线程。它可以利用机器上所有的核心，但是上下文切换很慢，因为它要通过OS进行切换。 M:N调度器。你可以得到快速的上下文切换，你可以利用系统中所有的核心。这种方法的主要缺点是它增加了调度器的复杂性。 摆脱上下文(在这里P就是上下文)？ 不行。我们使用上下文的原因是，如果正在运行的线程由于某些原因需要阻塞，我们可以将它们移交给其他线程。 以前就只有一个全局的P，也可以运行。必须要有P（上下文），是有什么值保存在里面？ why: threads get a lot of the same controls as processes. Threads have their own signal mask, can be assigned CPU affinity, can be put into cgroups and can be queried for which resources they use. All these controls add overhead for features that are simply not needed for how Go programs use goroutines and they quickly add up when you have 100,000 threads in your program."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="GMP"><meta property="og:description" content="golang GMP概念 # what: 是golang内部自己实现的调度器，由’‘G’’,“M”,“P&#34;用来调度goruntine，被称为&#34;GMP模型”。
GMP G:为了调度方便，保存寄存器，栈地址等->对应cpu切换[1.cpu寄存器的值；2.stack地址] M:与系统线程一一对应 P:一些上下文，比如局部P，防止锁，局部P的heap,也能防止加锁的导致的资源损耗。 why:
单进程时代不需要调度器
1.单一的执行流程，计算机只能一个任务一个任务处理。 2.进程阻塞所带来的CPU时间浪费。 多进程/线程时代有了调度器需求
1.解决了阻塞的问题 2.CPU有很大的一部分都被浪费在进程调度 设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。 协程(用户线程)来提高CPU利用率(减少CPU浪费在进程调度上)
为什么。 线程和进程有很多相同的控制权。线程有自己的信号掩码，可以分配CPU时间，可以放入cgroups，可以查询它们使用了哪些资源。所有这些控制都增加了一些功能的开销，而这些功能对于Go程序如何使用goroutine来说是根本不需要的，而且当你的程序中有10万个线程时，它们很快就会增加。 Go调度器可以做出只在它知道内存是一致的点进行调度的决定。 如何进行调度。 一种是N:1，即在一个操作系统线程上运行几个用户空间线程。这样做的好处是上下文切换非常快，但不能利用多核系统的优势。 另一种是1:1，一个执行线程匹配一个OS线程。它可以利用机器上所有的核心，但是上下文切换很慢，因为它要通过OS进行切换。 M:N调度器。你可以得到快速的上下文切换，你可以利用系统中所有的核心。这种方法的主要缺点是它增加了调度器的复杂性。 摆脱上下文(在这里P就是上下文)？ 不行。我们使用上下文的原因是，如果正在运行的线程由于某些原因需要阻塞，我们可以将它们移交给其他线程。 以前就只有一个全局的P，也可以运行。必须要有P（上下文），是有什么值保存在里面？ why: threads get a lot of the same controls as processes. Threads have their own signal mask, can be assigned CPU affinity, can be put into cgroups and can be queried for which resources they use. All these controls add overhead for features that are simply not needed for how Go programs use goroutines and they quickly add up when you have 100,000 threads in your program."><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/runtime/golang_gmp/"><meta property="article:section" content="docs"><title>GMP | go调度源码分析</title><link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png type=image/x-icon><link rel=stylesheet href=/go-goroutine/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script>
<script defer src=/go-goroutine/en.search.min.75f3025a21511955ad10f181cae208dd296ce24ee2a06def487a11decfa675f1.js integrity="sha256-dfMCWiFRGVWtEPGByuII3Sls4k7ioG3vSHoR3s+mdfE=" crossorigin=anonymous></script>
<script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/>基本用法</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/ class=active>GMP</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-99f41010918d678e89a7af90330cabe1 class=toggle>
<label for=section-99f41010918d678e89a7af90330cabe1 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>执行太久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>系统调用抢占</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script>
<script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu></label>
<strong>GMP</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#golang-gmp概念>golang GMP概念</a><ul><li><a href=#fqa>FQA</a><ul><li><a href=#g0m0gm>g0,m0,gM</a></li><li><a href=#说一说gmp的底层实现>说一说GMP的底层实现。</a></li></ul></li><li><a href=#archive>archive</a></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=golang-gmp概念>golang GMP概念
<a class=anchor href=#golang-gmp%e6%a6%82%e5%bf%b5>#</a></h1><ul><li><p>what: 是golang内部自己实现的调度器，由’‘G’’,“M”,“P"用来调度goruntine，被称为"GMP模型”。</p><ul><li>GMP<ul><li>G:为了调度方便，保存寄存器，栈地址等-><code>对应cpu切换[1.cpu寄存器的值；2.stack地址]</code></li><li>M:与系统线程一一对应</li><li>P:一些上下文，比如局部P，防止锁，局部P的heap,也能防止加锁的导致的资源损耗。</li></ul></li></ul></li><li><p>why:</p><ul><li><p>单进程时代不需要调度器</p><ul><li>1.单一的执行流程，计算机只能一个任务一个任务处理。</li><li>2.进程阻塞所带来的CPU时间浪费。</li></ul></li><li><p>多进程/线程时代有了调度器需求</p><ul><li>1.解决了阻塞的问题</li><li>2.CPU有很大的一部分都被浪费在进程调度</li><li>设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</li></ul></li><li><p>协程(用户线程)来提高CPU利用率(减少CPU浪费在进程调度上)</p></li></ul><blockquote><ul><li>为什么。<ul><li>线程和进程有很多相同的控制权。线程有自己的信号掩码，可以分配CPU时间，可以放入cgroups，可以查询它们使用了哪些资源。所有这些控制都增加了一些功能的开销，而这些功能对于Go程序如何使用goroutine来说是根本不需要的，而且当你的程序中有10万个线程时，它们很快就会增加。</li><li>Go调度器可以做出只在它知道内存是一致的点进行调度的决定。</li></ul></li><li>如何进行调度。<ul><li>一种是N:1，即在一个操作系统线程上运行几个用户空间线程。这样做的好处是上下文切换非常快，但不能利用多核系统的优势。</li><li>另一种是1:1，一个执行线程匹配一个OS线程。它可以利用机器上所有的核心，但是上下文切换很慢，因为它要通过OS进行切换。</li><li>M:N调度器。你可以得到快速的上下文切换，你可以利用系统中所有的核心。这种方法的主要缺点是它增加了调度器的复杂性。</li></ul></li><li>摆脱上下文(在这里P就是上下文)？<ul><li><del>不行。我们使用上下文的原因是，如果正在运行的线程由于某些原因需要阻塞，我们可以将它们移交给其他线程。</del></li><li>以前就只有一个全局的P，也可以运行。必须要有P（上下文），是有什么值保存在里面？</li></ul></li></ul></blockquote><blockquote><ul><li>why:<ul><li>threads get a lot of the same controls as processes. Threads have their own signal mask, can be assigned CPU affinity, can be put into cgroups and can be queried for which resources they use. All these controls add overhead for features that are simply not needed for how Go programs use goroutines and they quickly add up when you have 100,000 threads in your program.</li><li>Go调度器可以做出只在它知道内存是一致的点进行调度的决定。</li></ul></li><li>how:<ul><li>One is N:1 where several userspace threads are run on one OS thread. This has the advantage of being very quick to context switch but cannot take advantage of multi-core systems.</li><li>Another is 1:1 where one thread of execution matches one OS thread. It takes advantage of all of the cores on the machine, but context switching is slow because it has to trap through the OS.</li><li>M:N scheduler. You get quick context switches and you take advantage of all the cores in your system. The main disadvantage of this approach is the complexity it adds to the scheduler.</li></ul></li><li>get rid of contexts?<ul><li>Not really. The reason we have contexts is so that we can hand them off to other threads if the running thread needs to block for some reason.</li></ul></li></ul></blockquote><hr><blockquote><p>这个也就说明了<code>N-M</code>的基础，用户线程的各自栈空间其实就是放在公共的堆（heap）上。</p><blockquote><p>每个系统线程都有一个唯一的m0, g0与之对应，想想为什么？(g0的栈空间与其他的不同，它是放在系统线程的栈空间，**应该是进程的栈空间？**TODO,线程的栈空间)</p><blockquote><p>每个线程有自己的栈空间(而这个g0就在这个栈上)。但是是与其他的线程公用的<del>代码段</del>，<strong>数据段，堆空间</strong>,</p><blockquote><p>所以当创建其他的goroutine的时候，把它的协裎栈在堆上，所以它可以被其他的M调用。</p></blockquote></blockquote></blockquote></blockquote></li><li><p>how:</p><ul><li>Go调度本质是把<strong>大量的goroutine分配到少量系统线程</strong>上去执行，并利用多核并行，实现更强大的并发。<ul><li>通过这一点去记住，把大量goroutine分配到小量线程去尽快执行<ul><li>复用</li><li>并发</li><li>防止饥饿</li><li>全局G</li></ul></li></ul></li></ul><blockquote><ul><li>调度器的有两大思想：
<a href=/go-goroutine/#zxc-anchor-1><sup>1</sup></a><ul><li><strong>压榨系统线程</strong>：协程本身就是运行在一组线程之上，不需要频繁的创建、销毁线程，而是对线程的复用。在调度器中复用线程还有2个体现：<ul><li><strong>work stealing(<em>不让它休息</em>)</strong>，当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</li><li><strong>hand off(<em>阻塞了，那就换一个压榨</em>)</strong>，当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</li></ul></li><li><strong>利用并行</strong>：GOMAXPROCS设置P的数量，当GOMAXPROCS大于1时，就最多有GOMAXPROCS个线程处于运行状态，<strong>这些线程可能分布在多个CPU核上同时运行</strong>，使得并发利用并行。另外，GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。<ul><li>golang并发和并行：Rob Pike一直在强调Go是并发，不是并行，因为Go做的是在一段时间内完成几十万、甚至几百万的工作，而不是同一时间同时在做大量的工作。并发可以利用并行提高效率，调度器是有并行设计的。</li></ul></li></ul></li><li>调度器的两小策略：<ul><li>抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，<strong>这就是goroutine不同于coroutine的一个地方</strong>。</li><li>全局G队列：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</li></ul></li></ul></blockquote></li></ul><ul><li><a href=/go-goroutine/#golang-gmp%e6%a6%82%e5%bf%b5>golang GMP概念</a><ul><li><a href=/go-goroutine/#fqa>FQA</a><ul><li><a href=/go-goroutine/#g0m0gm>g0,m0,gM</a></li><li><a href=/go-goroutine/#%e8%af%b4%e4%b8%80%e8%af%b4gmp%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0>说一说GMP的底层实现。</a><ul><li><a href=/go-goroutine/#%e4%bb%8e%e7%a8%8b%e5%ba%8f%e5%8a%a0%e8%bd%bd%e5%88%b0main%e5%87%bd%e6%95%b0%e6%89%a7%e8%a1%8c%e7%9a%84%e8%bf%87%e7%a8%8b>从程序加载到main函数执行的过程。</a></li><li><a href=/go-goroutine/#%e6%96%b0%e7%9a%84goroutine%e5%88%9b%e5%bb%ba%e7%9a%84%e8%bf%87%e7%a8%8bnewproc>新的goroutine创建的过程newproc()。</a></li><li><a href=/go-goroutine/#%e8%b0%83%e5%ba%a6%e7%9a%84%e8%bf%87%e7%a8%8bschedule>调度的过程schedule()。</a></li></ul></li></ul></li><li><a href=/go-goroutine/#archive>archive</a></li><li><a href=/go-goroutine/#%e9%99%84%e5%bd%95>附录</a></li></ul></li></ul><h2 id=fqa>FQA
<a class=anchor href=#fqa>#</a></h2><h3 id=g0m0gm>g0,m0,gM
<a class=anchor href=#g0m0gm>#</a></h3><blockquote><p>我们知道g0,m0是开始就创建的，那么后面创建了gM，它是新建一个M，还是使用m0？</p><blockquote><p>从图中可以看到是使用m0:<code>https://zput.github.io/go-goroutine/part1.%E8%BF%9B%E5%85%A5main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1.%E8%BF%9B%E5%85%A5main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.html#mstart</code>
一个M对应一个系统线程，那么你想在程序开始的时候就会进行又创建一个系统线程？</p></blockquote></blockquote><h3 id=说一说gmp的底层实现>说一说GMP的底层实现。
<a class=anchor href=#%e8%af%b4%e4%b8%80%e8%af%b4gmp%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0>#</a></h3><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/GO/goroutine%E8%B0%83%E5%BA%A6.png alt=GMP大全></li></ul><h4 id=从程序加载到main函数执行的过程>从程序加载到main函数执行的过程。
<a class=anchor href=#%e4%bb%8e%e7%a8%8b%e5%ba%8f%e5%8a%a0%e8%bd%bd%e5%88%b0main%e5%87%bd%e6%95%b0%e6%89%a7%e8%a1%8c%e7%9a%84%e8%bf%87%e7%a8%8b>#</a></h4><ul><li>两条主线 + GMP经典图：<ul><li>那个经典的GMP在这一阶段实际是怎么表示的，(g0,m0,allp[0]),</li><li>代码加载到内存中的code segment, 从<code>入口-->runtime.main-->main.main</code>.</li><li>从全局变量的角度，全局变量<ul><li><code>(g0,m0,sched)</code>; &mdash;&#187;> <code>sched(midle, pidle, runq(全局运行goroutine queue))</code>.</li><li><code>(allg,allm,allp[0,...])</code>;</li></ul></li></ul></li><li>进行<code>mcall()-->schedule()</code>.</li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210114101912.png alt=20210114101912></p><blockquote><p>从上面就引出了创建新G，与调度问题：<code>newproc(),与mcall()--->schedule()</code></p></blockquote><h4 id=新的goroutine创建的过程newproc>新的goroutine创建的过程newproc()。
<a class=anchor href=#%e6%96%b0%e7%9a%84goroutine%e5%88%9b%e5%bb%ba%e7%9a%84%e8%bf%87%e7%a8%8bnewproc>#</a></h4><ul><li><p>创造一个新<strong>goroutine</strong>[<code>go myfunc()</code>]:</p><ul><li>它的最终结果一定是: 就像是goexist()函数调用这个<code>myfunc函数一样</code>。</li><li>创造一个新的goroutine前会在全局里面找看是否有<code>gidle的goroutine</code>.</li><li>最后会<code>runput</code>到队列中（可能是本地，可能是全局）。</li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210114142644.png alt=20210114142644></p></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/c05b9cda-5f30-4f90-9cd5-379a28005a86.jpg alt=c05b9cda-5f30-4f90-9cd5-379a28005a86></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/748394d1-2bc0-4cbc-b8c4-ef019908a993.jpg alt=newproc的过程></p><h4 id=调度的过程schedule>调度的过程schedule()。
<a class=anchor href=#%e8%b0%83%e5%ba%a6%e7%9a%84%e8%bf%87%e7%a8%8bschedule>#</a></h4><p>TODO
<a href=https://github.com/golang/go/blob/fa18f224c378f5831210077944e5df718efb8df5/src/runtime/asm_arm64.s#L126>TEXT runtime·gogo(SB), NOSPLIT|NOFRAME, $0-8</a></p><ul><li><ol><li>程序到达调度的时机;</li></ol></li><li><ol start=2><li>选取下一个Goroutine;</li></ol><ul><li>全局：globrunqget()<ul><li>从全局里面拿不是每次只拿一个，而是拿多个，多余一个的放入本地运行G队列(<code>runqput(_p_ *p, gp *g, next bool)</code>)。</li></ul></li><li>本地P：runqget()</li><li>从其他的P中偷：findrunnable()<ul><li>sched.gcwaiting</li><li>local runq</li><li>global runq</li><li>netpoll</li><li>steal from other P</li></ul></li></ul></li><li><ol start=3><li>切换Goroutine cpu执行选出的Goroutine.</li></ol></li></ul><p>抢占的分类</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/fb2d3bf7-d5f6-4421-b191-b087cc0ddf5a.jpg alt=fb2d3bf7-d5f6-4421-b191-b087cc0ddf5a></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/539b9267-7355-49e1-95a5-5e8b1392c19e.jpg alt=539b9267-7355-49e1-95a5-5e8b1392c19e></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/9b452c91-7377-4707-8596-a2f2ff8704e5.jpg alt=9b452c91-7377-4707-8596-a2f2ff8704e5></p><ul><li>抢占又分为：函数抢占，和信号抢占<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210114145818.png alt="stack Preempt"></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/e274fe0e-275c-4072-aefc-da53922e36e7.jpg alt="async(signal) Preempt"></li><li></li></ul></li></ul><h2 id=archive>archive
<a class=anchor href=#archive>#</a></h2><ul><li>谈一谈GMP
我们在C++一般的运行一个线程就是调用系统函数创建一个系统线程。
1-1 N-1 N-M(如果说1-1是)
预先创建一堆线程池，然后用户代码里面接收请求，来一个请求handle一个。</li></ul><hr><ul><li>202104月总结<ul><li>没有按照what，why, how顺序来说:<ul><li>what里面没有阐述G，M，P的实际是什么.</li><li>why里面没有把握<strong>调度</strong>这个思想.<ul><li>单进程里面<strong>不需要</strong>调度，但是可能进程阻塞。</li><li>多线程<strong>需要调度</strong>，解决了阻塞，<ul><li>但是调度在内核态，调度花费时间长，</li><li>线程笨重，有自己的信号掩码，。。。// TODO</li></ul></li><li>用户态调度，<strong>需要调度</strong>, 比如协程，goroutine.<ul><li>由协程与系统线程的关联比例，可以分为<code>[1 : N] [N : 1] [M : N]</code>.</li></ul></li></ul></li><li>how里面要点出主旨：把大量的goroutine高效的分配给少量的系统线程。<ul><li>二个策略：<ul><li>压榨系统线程：<ul><li>M执行P队列中的G完了，不让它销毁或者停止，从别的地方拿</li><li>当陷入系统调用中，让M-G关联，P重新拿一个M执行剩下的G.</li></ul></li><li>P的策略，可控制程序的并行数量，[与实际机器的CPU核数]</li></ul></li><li>两个小策略：<ul><li>防止饥饿；</li><li>保留一个全局P，当局部P满了，可以放入全局P中。</li></ul></li></ul></li></ul></li></ul></li></ul><hr><h2 id=附录>附录
<a class=anchor href=#%e9%99%84%e5%bd%95>#</a></h2><p><span id=zxc-anchor-1></span></p><ul><li><p>[1]
<a href=https://mp.weixin.qq.com/s/epWDv9Nrmgg4ySFlk1gGKg>我是大彬: Go调度器系列</a></p></li><li><p>[2]
<a href=https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit>Scalable Go Scheduler Design Doc</a></p></li><li><p><a href=https://lessisbetter.site/2019/04/14/golang-scheduler-4-explore-source-code/>https://lessisbetter.site/2019/04/14/golang-scheduler-4-explore-source-code/</a></p></li><li><p><a href="https://speakerdeck.com/kavya719/the-scheduler-saga?slide=103">https://speakerdeck.com/kavya719/the-scheduler-saga?slide=103</a></p></li><li><p><a href="https://www.cnblogs.com/CodeWithTxT/p/11370215.html#:~:text=%E4%B8%BA%E4%BA%86%E6%9B%B4%E5%90%88%E7%90%86%E7%9A%84%E5%88%A9%E7%94%A8,%E5%88%86%E5%9C%B0%E5%88%A9%E7%94%A8CPU%E3%80%82">https://www.cnblogs.com/CodeWithTxT/p/11370215.html#:~:text=%E4%B8%BA%E4%BA%86%E6%9B%B4%E5%90%88%E7%90%86%E7%9A%84%E5%88%A9%E7%94%A8,%E5%88%86%E5%9C%B0%E5%88%A9%E7%94%A8CPU%E3%80%82</a></p></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#golang-gmp概念>golang GMP概念</a><ul><li><a href=#fqa>FQA</a><ul><li><a href=#g0m0gm>g0,m0,gM</a></li><li><a href=#说一说gmp的底层实现>说一说GMP的底层实现。</a></li></ul></li><li><a href=#archive>archive</a></li><li><a href=#附录>附录</a></li></ul></li></ul></nav></div></aside></main></body></html>