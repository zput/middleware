<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="count函数 # count()是一个函数，他的形参可以是一个字段或表达式; 函数逻辑是统计符合查询条件的记录中，如果使当前字段/表达式不为null的个数。比如select count(1) from tmp_table; 那么就是统计tmp_table表有多少行，因它的每个记录都不会使得表达式1为null。返回是统计结果
count(*)==count(1) > count(聚簇索引) >= count(非聚簇索引) > count(非索引字段) count(*)等同于count(1) # InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.
不需要读取记录中的字段值然后再去判断, 所以server层不需要innodb返回字段
count(聚簇索引) # 有辅助索引时，InnoDB循环遍历的对象就不是聚簇索引，而是辅助索引。
如果有多个辅助索引, 优化器会使用key_len,挑选最小的辅助索引进行扫描。
这是因为相同数量的辅助索引记录可以比聚簇索引记录占用更少的存储空间，所以辅助索引树比聚簇(主键)索引树小，这样遍历辅助索引的 I/O 成本比遍历聚簇(主键)索引的 I/O 成本小，因此「优化器」优先选择的是最小的辅助索引。
count(非聚簇索引) # 使用辅助索引来进行统计"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="聚合函数"><meta property="og:description" content="count函数 # count()是一个函数，他的形参可以是一个字段或表达式; 函数逻辑是统计符合查询条件的记录中，如果使当前字段/表达式不为null的个数。比如select count(1) from tmp_table; 那么就是统计tmp_table表有多少行，因它的每个记录都不会使得表达式1为null。返回是统计结果
count(*)==count(1) > count(聚簇索引) >= count(非聚簇索引) > count(非索引字段) count(*)等同于count(1) # InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.
不需要读取记录中的字段值然后再去判断, 所以server层不需要innodb返回字段
count(聚簇索引) # 有辅助索引时，InnoDB循环遍历的对象就不是聚簇索引，而是辅助索引。
如果有多个辅助索引, 优化器会使用key_len,挑选最小的辅助索引进行扫描。
这是因为相同数量的辅助索引记录可以比聚簇索引记录占用更少的存储空间，所以辅助索引树比聚簇(主键)索引树小，这样遍历辅助索引的 I/O 成本比遍历聚簇(主键)索引的 I/O 成本小，因此「优化器」优先选择的是最小的辅助索引。
count(非聚簇索引) # 使用辅助索引来进行统计"><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/middleware/docs/mysql/advanced/function/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2016-03-26T08:47:11+00:00"><meta property="article:modified_time" content="2016-03-26T08:47:11+00:00"><title>聚合函数 | 常用中间件分析</title><link rel=manifest href=/middleware/manifest.json><link rel=icon href=/middleware/favicon.png type=image/x-icon><link rel=stylesheet href=/middleware/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/middleware/flexsearch.min.js></script>
<script defer src=/middleware/en.search.min.c728f0ed5b7d0799a39d51eaa901b5f0ef885f86801498299786e21f3cd56e29.js integrity="sha256-xyjw7Vt9B5mjnVHqqQG18O+IX4aAFJgpl4biHzzVbik=" crossorigin=anonymous></script>
<script defer src=/middleware/sw.min.f609352e1b128d348128bfdb614a37fe64cd10a16425cbece15ecafa5115c45a.js integrity="sha256-9gk1LhsSjTSBKL/bYUo3/mTNEKFkJcvs4V7K+lEVxFo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/middleware/><span>常用中间件分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>Mysql</span><ul><li><a href=/middleware/docs/mysql/init/>开始篇</a><ul><li><a href=/middleware/docs/mysql/init/install/>初始化</a></li></ul></li><li><a href=/middleware/docs/mysql/business_facing/>面向业务篇</a><ul><li><a href=/middleware/docs/mysql/business_facing/sql/>写好sql</a></li><li><a href=/middleware/docs/mysql/business_facing/innodb_index/>索引</a></li><li><a href=/middleware/docs/mysql/business_facing/innodb_lock/>锁</a></li></ul></li><li><span>高级篇</span><ul><li><span>ACID</span><ul><li><a href=/middleware/docs/mysql/advanced/ACID/isolution/>隔离性-锁</a></li></ul></li><li><a href=/middleware/docs/mysql/advanced/innodb_index/>索引</a></li><li><a href=/middleware/docs/mysql/advanced/function/ class=active>聚合函数</a></li><li><a href=/middleware/docs/mysql/advanced/log/>三种日志</a></li><li><a href=/middleware/docs/mysql/advanced/segment_extent_page/>页的结构</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/middleware/magic.js></script>
<script src=/middleware/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/middleware/svg/menu.svg class=book-icon alt=Menu></label>
<strong>聚合函数</strong>
<label for=toc-control><img src=/middleware/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#count函数>count函数</a><ul><li><a href=#count等同于count1>count(*)等同于count(1)</a></li><li><a href=#count聚簇索引>count(聚簇索引)</a></li><li><a href=#count非聚簇索引>count(非聚簇索引)</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=count函数>count函数
<a class=anchor href=#count%e5%87%bd%e6%95%b0>#</a></h1><p>count()是一个函数，他的形参可以是一个字段或表达式;
函数逻辑是统计符合查询条件的记录中，如果使当前字段/表达式不为null的个数。比如select count(1) from tmp_table; 那么就是统计tmp_table表有多少行，因它的每个记录都不会使得表达式1为null。返回是统计结果</p><pre tabindex=0><code>count(*)==count(1) &gt; count(聚簇索引) &gt;= count(非聚簇索引) &gt; count(非索引字段)
</code></pre><h2 id=count等同于count1>count(*)等同于count(1)
<a class=anchor href=#count%e7%ad%89%e5%90%8c%e4%ba%8ecount1>#</a></h2><p>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</p><p>不需要读取记录中的字段值然后再去判断, 所以server层不需要innodb返回字段</p><h2 id=count聚簇索引>count(聚簇索引)
<a class=anchor href=#count%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95>#</a></h2><p>有辅助索引时，InnoDB循环遍历的对象就不是聚簇索引，而是辅助索引。</p><p>如果有多个辅助索引, 优化器会使用key_len,挑选最小的辅助索引进行扫描。</p><p>这是因为相同数量的辅助索引记录可以比聚簇索引记录占用更少的存储空间，所以辅助索引树比聚簇(主键)索引树小，这样遍历辅助索引的 I/O 成本比遍历聚簇(主键)索引的 I/O 成本小，因此「优化器」优先选择的是最小的辅助索引。</p><h2 id=count非聚簇索引>count(非聚簇索引)
<a class=anchor href=#count%e9%9d%9e%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95>#</a></h2><p>使用辅助索引来进行统计</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#count函数>count函数</a><ul><li><a href=#count等同于count1>count(*)等同于count(1)</a></li><li><a href=#count聚簇索引>count(聚簇索引)</a></li><li><a href=#count非聚簇索引>count(非聚簇索引)</a></li></ul></li></ul></nav></div></aside></main></body></html>