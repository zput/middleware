<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="索引的分类 # 从分类入手，从底层索引的物理结构开始讨论构建索引的自己规范：
按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。 按「字段个数」分类：单列索引、联合索引。
索引建立标准 # 从业务：经常where/group by / order by 从物理结构: 字段区分度要大(最好是唯一性) 从物理结构: 非经常变更的字段，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。 自增类型 从业务 # 从物理结构 # // TODO 添加 索引底层页的物理结构 // TODO 添加 联合索引的物理结构
首先创建索引和维护索引要耗费时间:
占用物理空间，数量越多，占用空间越大； B+ 树为了维护索引有序性，都需要进行动态维护。 (聚簇)主键索引最好是自增的 # InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。
如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。
如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。
举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：
(非聚簇)二级索引 # 区分度太小的不适合 # // 区分度太小的也不适合做索引，比如sex字段，它的值一般不超过三个，区分度太小，你就算找到了sex=man的，你还是需要在它剩下的里面查找b,c,这种相当于查找了三分之一个表。还需要回表。
联合索引的顺序要挑选最常用的在最前面 # (a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。 联合索引的最左匹配原则，在遇到范围查询（>、<、between、like 包括like &lsquo;林%&lsquo;这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引。 // 就知道了它对于联合索引的一些问题，比如a,b,c; where b,c的时候就不会进过索引。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="索引"><meta property="og:description" content="索引的分类 # 从分类入手，从底层索引的物理结构开始讨论构建索引的自己规范：
按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。 按「字段个数」分类：单列索引、联合索引。
索引建立标准 # 从业务：经常where/group by / order by 从物理结构: 字段区分度要大(最好是唯一性) 从物理结构: 非经常变更的字段，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。 自增类型 从业务 # 从物理结构 # // TODO 添加 索引底层页的物理结构 // TODO 添加 联合索引的物理结构
首先创建索引和维护索引要耗费时间:
占用物理空间，数量越多，占用空间越大； B+ 树为了维护索引有序性，都需要进行动态维护。 (聚簇)主键索引最好是自增的 # InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。
如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。
如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。
举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：
(非聚簇)二级索引 # 区分度太小的不适合 # // 区分度太小的也不适合做索引，比如sex字段，它的值一般不超过三个，区分度太小，你就算找到了sex=man的，你还是需要在它剩下的里面查找b,c,这种相当于查找了三分之一个表。还需要回表。
联合索引的顺序要挑选最常用的在最前面 # (a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。 联合索引的最左匹配原则，在遇到范围查询（>、<、between、like 包括like &lsquo;林%&lsquo;这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引。 // 就知道了它对于联合索引的一些问题，比如a,b,c; where b,c的时候就不会进过索引。"><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/middleware/docs/mysql/advanced/innodb_index/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2016-03-26T08:47:11+00:00"><meta property="article:modified_time" content="2016-03-26T08:47:11+00:00"><title>索引 | 常用中间件分析</title><link rel=manifest href=/middleware/manifest.json><link rel=icon href=/middleware/favicon.png type=image/x-icon><link rel=stylesheet href=/middleware/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/middleware/flexsearch.min.js></script>
<script defer src=/middleware/en.search.min.16f0fd76f088d1c1f122239c8ef7fcb1c5e8fd92da71998ef907639aeaf3ca0a.js integrity="sha256-FvD9dvCI0cHxIiOcjvf8scXo/ZLacZmO+Qdjmurzygo=" crossorigin=anonymous></script>
<script defer src=/middleware/sw.min.f609352e1b128d348128bfdb614a37fe64cd10a16425cbece15ecafa5115c45a.js integrity="sha256-9gk1LhsSjTSBKL/bYUo3/mTNEKFkJcvs4V7K+lEVxFo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/middleware/><span>常用中间件分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>Mysql</span><ul><li><a href=/middleware/docs/mysql/init/>开始篇</a><ul><li><a href=/middleware/docs/mysql/init/install/>初始化</a></li></ul></li><li><a href=/middleware/docs/mysql/business_facing/>面向业务篇</a><ul><li><a href=/middleware/docs/mysql/business_facing/sql/>写好sql</a></li><li><a href=/middleware/docs/mysql/business_facing/innodb_index/>索引</a></li><li><a href=/middleware/docs/mysql/business_facing/innodb_lock/>锁</a></li></ul></li><li><span>高级篇</span><ul><li><span>ACID</span><ul><li><a href=/middleware/docs/mysql/advanced/ACID/isolution/>隔离性-锁</a></li></ul></li><li><a href=/middleware/docs/mysql/advanced/innodb_index/ class=active>索引</a></li><li><a href=/middleware/docs/mysql/advanced/function/>聚合函数</a></li><li><a href=/middleware/docs/mysql/advanced/log/>三种日志</a></li><li><a href=/middleware/docs/mysql/advanced/segment_extent_page/>页的结构</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/middleware/magic.js></script>
<script src=/middleware/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/middleware/svg/menu.svg class=book-icon alt=Menu></label>
<strong>索引</strong>
<label for=toc-control><img src=/middleware/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#索引的分类>索引的分类</a></li><li><a href=#索引建立标准>索引建立标准</a><ul><li><a href=#从业务>从业务</a></li><li><a href=#从物理结构>从物理结构</a><ul><li><a href=#聚簇主键索引最好是自增的>(聚簇)主键索引最好是自增的</a></li><li><a href=#非聚簇二级索引>(非聚簇)二级索引</a></li></ul></li><li><a href=#索引最好设置为-not-null>索引最好设置为 NOT NULL</a></li></ul></li><li><a href=#索引>索引</a></li></ul></nav></aside></header><article class=markdown><h1 id=索引的分类>索引的分类
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e7%9a%84%e5%88%86%e7%b1%bb>#</a></h1><p>从分类入手，从底层索引的物理结构开始讨论构建索引的自己规范：</p><p>按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
按「字段个数」分类：单列索引、联合索引。</p><h1 id=索引建立标准>索引建立标准
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e5%bb%ba%e7%ab%8b%e6%a0%87%e5%87%86>#</a></h1><ul><li>从业务：经常where/group by / order by</li><li>从物理结构: 字段区分度要大(最好是唯一性)</li><li>从物理结构: <strong>非经常变更的字段</strong>，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li><li>自增类型</li></ul><h2 id=从业务>从业务
<a class=anchor href=#%e4%bb%8e%e4%b8%9a%e5%8a%a1>#</a></h2><h2 id=从物理结构>从物理结构
<a class=anchor href=#%e4%bb%8e%e7%89%a9%e7%90%86%e7%bb%93%e6%9e%84>#</a></h2><p>// TODO 添加 索引底层页的物理结构
// TODO 添加 联合索引的物理结构</p><p>首先创建索引和维护索引要耗费时间:</p><ul><li>占用物理空间，数量越多，占用空间越大；</li><li>B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><h3 id=聚簇主键索引最好是自增的>(聚簇)主键索引最好是自增的
<a class=anchor href=#%e8%81%9a%e7%b0%87%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e6%9c%80%e5%a5%bd%e6%98%af%e8%87%aa%e5%a2%9e%e7%9a%84>#</a></h3><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p>如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。</p><p>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p><p>举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：</p><h3 id=非聚簇二级索引>(非聚簇)二级索引
<a class=anchor href=#%e9%9d%9e%e8%81%9a%e7%b0%87%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95>#</a></h3><h4 id=区分度太小的不适合>区分度太小的不适合
<a class=anchor href=#%e5%8c%ba%e5%88%86%e5%ba%a6%e5%a4%aa%e5%b0%8f%e7%9a%84%e4%b8%8d%e9%80%82%e5%90%88>#</a></h4><p>// 区分度太小的也不适合做索引，比如sex字段，它的值一般不超过三个，区分度太小，你就算找到了sex=man的，你还是需要在它剩下的里面查找b,c,这种相当于查找了三分之一个表。还需要回表。</p><h4 id=联合索引的顺序要挑选最常用的在最前面>联合索引的顺序要挑选最常用的在最前面
<a class=anchor href=#%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e7%9a%84%e9%a1%ba%e5%ba%8f%e8%a6%81%e6%8c%91%e9%80%89%e6%9c%80%e5%b8%b8%e7%94%a8%e7%9a%84%e5%9c%a8%e6%9c%80%e5%89%8d%e9%9d%a2>#</a></h4><ul><li>(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。<ul><li>联合索引的最左匹配原则，在遇到范围查询（>、&lt;、between、like 包括like &lsquo;林%&lsquo;这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引。</li></ul></li></ul><p>// 就知道了它对于联合索引的一些问题，比如a,b,c; where b,c的时候就不会进过索引。</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li></ul><h2 id=索引最好设置为-not-null>索引最好设置为 NOT NULL
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e6%9c%80%e5%a5%bd%e8%ae%be%e7%bd%ae%e4%b8%ba-not-null>#</a></h2><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p><p>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</p><p>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式COMPACT，会用 1 字节空间存储 NULL 值列表，如下图的黄色部分：</p><h1 id=索引>索引
<a class=anchor href=#%e7%b4%a2%e5%bc%95>#</a></h1><ul><li><p>what:
<a href=https://www.tutorialspoint.com/mysql/mysql-indexes.htm>A database index is a data structure that improves the speed of operations in a table</a></p><ul><li>不在<strong>索引列</strong>上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。</li><li>索引中<strong>范围条件</strong>右边的字段会全部失效。</li><li>MySQL在使用<code>!=</code>或者<code>&lt;></code>的时候无法使用索引会导致全表扫描。</li><li><code>is null</code>、<code>is not null</code>也无法使用索引。</li><li><code>like</code>以通配符开头<code>%abc</code>索引失效会变成全表扫描。</li><li>字符串不加单引号索引失效。</li><li>少用<code>or</code>，用它来连接时会索引失效。</li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#索引的分类>索引的分类</a></li><li><a href=#索引建立标准>索引建立标准</a><ul><li><a href=#从业务>从业务</a></li><li><a href=#从物理结构>从物理结构</a><ul><li><a href=#聚簇主键索引最好是自增的>(聚簇)主键索引最好是自增的</a></li><li><a href=#非聚簇二级索引>(非聚簇)二级索引</a></li></ul></li><li><a href=#索引最好设置为-not-null>索引最好设置为 NOT NULL</a></li></ul></li><li><a href=#索引>索引</a></li></ul></nav></div></aside></main></body></html>