<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ACID on 常用中间件分析</title><link>https://zput.github.io/middleware/docs/mysql/advanced/ACID/</link><description>Recent content in ACID on 常用中间件分析</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 26 Mar 2016 08:47:11 +0000</lastBuildDate><atom:link href="https://zput.github.io/middleware/docs/mysql/advanced/ACID/index.xml" rel="self" type="application/rss+xml"/><item><title>隔离性-锁</title><link>https://zput.github.io/middleware/docs/mysql/advanced/ACID/isolution/</link><pubDate>Sat, 26 Mar 2016 08:47:11 +0000</pubDate><guid>https://zput.github.io/middleware/docs/mysql/advanced/ACID/isolution/</guid><description>锁原理 # 首先，如果要你实现一把锁，该如何实现呢？就从简单到复杂,慢慢考虑性能等一些因素。
一个变量 一个抢占动作: 抢占失败(比如已经被其他线程抢占了)处理: immediately-retry yield sleep park mix(immediately-retry, yield/sleep/park) 重试 下面是它的伪代码:
var v = 0 func unlock(){ //解锁 v=0 } func lock(){ //加锁 retry: if !CompareAndSet(0, 1){ handleErr() goto retry } } func handleErr(){ // 处理方式有如下几种 // immediately-retry // yield // sleep // park // mix(immediately-retry, yield/sleep/park) } func CompareAndSet(except, newValue int)bool{ //cas操作,如果修改v则返回true } 下面我们来讲讲这几种CAS失败后处理方式。
自旋 # 最容易想到可能是自旋：
func handleErr(){ // 可以使用CPU提供的PAUSE指令来实现「忙等待」，因为可以减少循环等待时的耗电量 return // 直接返回，马上重试// immediately-retry } 这样实现的锁显然有个致命的缺点：耗费cpu资源。没有竞争到锁的线程会一直占用cpu资源进行cas操作，假如一个线程获得锁后要花费10s处理业务逻辑，那另外一个线程就会白白的花费10s的cpu资源。（假设系统中就只有这两个线程的情况）。</description></item></channel></rss>