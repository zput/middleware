<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="log # redo log # what: 物理格式日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。 why: 确保事务的持久性。 防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。 how: 什么时候产生： 事务开始之后就产生redo log，redo log的落盘并不是当事务提交时才写入的，而是在事务的执行过程中，便开始写入redo log文件中。 重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。 然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘 Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。 每个事务提交时会将重做日志刷新到重做日志文件。 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件 什么时候释放： 当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。 对应的物理文件： 默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2 innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。 innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2 关于文件的大小和数量，由一下两个参数配置 innodb_log_file_size 重做日志文件的大小。 innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1 undo log回滚日志 # what: 逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。 why: 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读 how: 什么时候产生： 事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性 什么时候释放： 当事务提交之后，undo log并不能立马被删除， 而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。 对应的物理文件： MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。 MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。 关于MySQL5.7之后的独立undo 表空间配置参数如下 innodb_undo_directory = /data/undospace/ &ndash;undo独立表空间的存放目录 innodb_undo_logs = 128 &ndash;回滚段为128KB innodb_undo_tablespaces = 4 &ndash;指定有4个undo log文件 如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。 其他： undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。 默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。 因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="三种日志"><meta property="og:description" content="log # redo log # what: 物理格式日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。 why: 确保事务的持久性。 防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。 how: 什么时候产生： 事务开始之后就产生redo log，redo log的落盘并不是当事务提交时才写入的，而是在事务的执行过程中，便开始写入redo log文件中。 重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。 然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘 Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。 每个事务提交时会将重做日志刷新到重做日志文件。 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件 什么时候释放： 当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。 对应的物理文件： 默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2 innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。 innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2 关于文件的大小和数量，由一下两个参数配置 innodb_log_file_size 重做日志文件的大小。 innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1 undo log回滚日志 # what: 逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。 why: 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读 how: 什么时候产生： 事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性 什么时候释放： 当事务提交之后，undo log并不能立马被删除， 而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。 对应的物理文件： MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。 MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。 关于MySQL5.7之后的独立undo 表空间配置参数如下 innodb_undo_directory = /data/undospace/ &ndash;undo独立表空间的存放目录 innodb_undo_logs = 128 &ndash;回滚段为128KB innodb_undo_tablespaces = 4 &ndash;指定有4个undo log文件 如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。 其他： undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。 默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。 因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的."><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/middleware/docs/mysql/advanced/log/"><meta property="article:section" content="docs"><title>三种日志 | 常用中间件分析</title><link rel=manifest href=/middleware/manifest.json><link rel=icon href=/middleware/favicon.png type=image/x-icon><link rel=stylesheet href=/middleware/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/middleware/flexsearch.min.js></script>
<script defer src=/middleware/en.search.min.43025b87777f1b1c82d61607e7489239174b3f87b772659acd151404fe3ceca7.js integrity="sha256-QwJbh3d/GxyC1hYH50iSORdLP4e3cmWazRUUBP487Kc=" crossorigin=anonymous></script>
<script defer src=/middleware/sw.min.f609352e1b128d348128bfdb614a37fe64cd10a16425cbece15ecafa5115c45a.js integrity="sha256-9gk1LhsSjTSBKL/bYUo3/mTNEKFkJcvs4V7K+lEVxFo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/middleware/><span>常用中间件分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>Mysql</span><ul><li><a href=/middleware/docs/mysql/init/>开始篇</a><ul><li><a href=/middleware/docs/mysql/init/install/>初始化</a></li></ul></li><li><a href=/middleware/docs/mysql/business_facing/>面向业务篇</a><ul><li><a href=/middleware/docs/mysql/business_facing/sql/>写好sql</a></li><li><a href=/middleware/docs/mysql/business_facing/innodb_index/>索引</a></li><li><a href=/middleware/docs/mysql/business_facing/innodb_lock/>锁</a></li></ul></li><li><span>高级篇</span><ul><li><span>ACID</span><ul><li><a href=/middleware/docs/mysql/advanced/ACID/isolution/>隔离性-锁</a></li></ul></li><li><a href=/middleware/docs/mysql/advanced/innodb_index/>索引</a></li><li><a href=/middleware/docs/mysql/advanced/function/>聚合函数</a></li><li><a href=/middleware/docs/mysql/advanced/log/ class=active>三种日志</a></li><li><a href=/middleware/docs/mysql/advanced/segment_extent_page/>页的结构</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/middleware/magic.js></script>
<script src=/middleware/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/middleware/svg/menu.svg class=book-icon alt=Menu></label>
<strong>三种日志</strong>
<label for=toc-control><img src=/middleware/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#log>log</a><ul><li><a href=#redo-log>redo log</a></li><li><a href=#undo-log回滚日志>undo log回滚日志</a></li><li><a href=#binlog二进制日志>binlog二进制日志</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=log>log
<a class=anchor href=#log>#</a></h1><h2 id=redo-log>redo log
<a class=anchor href=#redo-log>#</a></h2><ul><li>what:<ul><li><strong>物理格式</strong>日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</li></ul></li><li>why:<ul><li>确保事务的持久性。</li><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</li></ul></li><li>how:<ul><li>什么时候产生：<ul><li>事务开始之后就产生<code>redo log</code>，<code>redo log</code>的落盘并不是当事务提交时才写入的，而是在事务的执行过程中，便开始写入<code>redo log</code>文件中。<ul><li>重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。</li><li>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘<ul><li><ol><li>Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</li></ol></li><li><ol start=2><li>每个事务提交时会将重做日志刷新到重做日志文件。</li></ol></li><li><ol start=3><li>当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件</li></ol></li></ul></li></ul></li></ul></li><li>什么时候释放：<ul><li>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</li></ul></li><li>对应的物理文件：<ul><li>默认情况下，对应的物理文件位于数据库的data目录下的<code>ib_logfile1&amp;ib_logfile2</code><ul><li>innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。</li><li>innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2</li></ul></li><li>关于文件的大小和数量，由一下两个参数配置<ul><li>innodb_log_file_size 重做日志文件的大小。</li><li>innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</li></ul></li></ul></li></ul></li></ul><h2 id=undo-log回滚日志>undo log回滚日志
<a class=anchor href=#undo-log%e5%9b%9e%e6%bb%9a%e6%97%a5%e5%bf%97>#</a></h2><ul><li>what:<ul><li><strong>逻辑格式</strong>的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，<strong>而不是从物理页面上操作实现</strong>的，这一点是不同于redo log的。</li></ul></li><li>why:<ul><li>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</li></ul></li><li>how:<ul><li>什么时候产生：<ul><li>事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</li></ul></li><li>什么时候释放：<ul><li>当事务提交之后，undo log并不能立马被删除，</li><li>而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</li></ul></li><li>对应的物理文件：<ul><li>MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。</li><li>MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</li><li>关于MySQL5.7之后的独立undo 表空间配置参数如下<ul><li>innodb_undo_directory = /data/undospace/ &ndash;undo独立表空间的存放目录</li><li>innodb_undo_logs = 128 &ndash;回滚段为128KB</li><li>innodb_undo_tablespaces = 4 &ndash;指定有4个undo log文件</li></ul></li><li>如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。</li></ul></li><li>其他：<ul><li>undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。</li><li>默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。</li><li>因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的.mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</li></ul></li></ul></li></ul><h2 id=binlog二进制日志>binlog二进制日志
<a class=anchor href=#binlog%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%97%a5%e5%bf%97>#</a></h2><ul><li><p>what:</p><ul><li>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</li><li>在使用mysqlbinlog解析binlog之后一些都会真相大白。</li></ul></li><li><p>why:</p><ul><li><ol><li>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</li></ol></li><li><ol start=2><li>用于数据库的基于时间点的还原。</li></ol></li></ul></li><li><p>how:</p><ul><li>什么时候产生：<ul><li>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</li><li>这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</li><li>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。<ul><li>这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</li></ul></li></ul></li><li>什么时候释放：<ul><li>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</li></ul></li><li>对应的物理文件：<ul><li>配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</li><li>对于每个binlog日志文件，通过一个统一的index文件来组织。</li></ul></li><li>二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同<ul><li><ol><li>作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</li></ol></li><li><ol start=2><li>内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</li></ol></li><li><ol start=3><li>另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</li></ol></li><li><ol start=4><li>恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</li></ol></li></ul></li></ul></li><li><p>MySQL通过<strong>两阶段提交</strong>过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p></li></ul><hr></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#log>log</a><ul><li><a href=#redo-log>redo log</a></li><li><a href=#undo-log回滚日志>undo log回滚日志</a></li><li><a href=#binlog二进制日志>binlog二进制日志</a></li></ul></li></ul></nav></div></aside></main></body></html>