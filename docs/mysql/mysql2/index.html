<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="0.重要的知识点 表空间的格式 页的结构 文件管理页 INODE页 INDEX数据索引页 聚簇和非聚簇 index Row Format what: what: how: 讨论innodb数据结构 log mvcc FQA 0.重要的知识点 # MySQL逻辑架构 1.1. 连接层 1.2. 服务层 1.3. 引擎层(存储引擎是基于表的，而不是数据库) 1.4. 存储层
如何修改字符集(查看1.3)
日志 3.1. 查询日志 3.2. 错误日志 3.3. 二进制日志
分析慢SQL的步骤 first:找到是那些sql慢. 4.1. 慢查询的开启，设置阈值(如超过5秒钟的就是慢SQL)并捕获。 second:开始分析这些sql. 4.2. explain + 慢SQL分析。 查询语句写的差。 关联 查询太多join（设计缺陷或者不得已的需求）。 索引失效：索引建了，但是没有用上。 4.3. show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。 4.4. MySQL数据库服务器的参数调优。 SQL执行顺序 select # 5 ----> ... from # 1 ... where # 2 .... group by # 3 ."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="mysql总结"><meta property="og:description" content="0.重要的知识点 表空间的格式 页的结构 文件管理页 INODE页 INDEX数据索引页 聚簇和非聚簇 index Row Format what: what: how: 讨论innodb数据结构 log mvcc FQA 0.重要的知识点 # MySQL逻辑架构 1.1. 连接层 1.2. 服务层 1.3. 引擎层(存储引擎是基于表的，而不是数据库) 1.4. 存储层
如何修改字符集(查看1.3)
日志 3.1. 查询日志 3.2. 错误日志 3.3. 二进制日志
分析慢SQL的步骤 first:找到是那些sql慢. 4.1. 慢查询的开启，设置阈值(如超过5秒钟的就是慢SQL)并捕获。 second:开始分析这些sql. 4.2. explain + 慢SQL分析。 查询语句写的差。 关联 查询太多join（设计缺陷或者不得已的需求）。 索引失效：索引建了，但是没有用上。 4.3. show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。 4.4. MySQL数据库服务器的参数调优。 SQL执行顺序 select # 5 ----> ... from # 1 ... where # 2 .... group by # 3 ."><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/middleware/docs/mysql/mysql2/"><meta property="article:section" content="docs"><title>mysql总结 | 常用中间件分析</title><link rel=manifest href=/middleware/manifest.json><link rel=icon href=/middleware/favicon.png type=image/x-icon><link rel=stylesheet href=/middleware/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/middleware/flexsearch.min.js></script>
<script defer src=/middleware/en.search.min.b7d7d346a31de829dab11245fa130d19fbfb17050e75b50e2cdd0f4c52d74c3b.js integrity="sha256-t9fTRqMd6CnasRJF+hMNGfv7FwUOdbUOLN0PTFLXTDs=" crossorigin=anonymous></script>
<script defer src=/middleware/sw.min.f609352e1b128d348128bfdb614a37fe64cd10a16425cbece15ecafa5115c45a.js integrity="sha256-9gk1LhsSjTSBKL/bYUo3/mTNEKFkJcvs4V7K+lEVxFo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/middleware/><span>常用中间件分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>Mysql</span><ul><li><a href=/middleware/docs/mysql/init/>开始篇</a><ul><li><a href=/middleware/docs/mysql/init/install/>初始化</a></li></ul></li><li><a href=/middleware/docs/mysql/business_facing/>面向业务篇</a><ul><li><a href=/middleware/docs/mysql/business_facing/sql/>写好sql</a></li><li><a href=/middleware/docs/mysql/business_facing/innodb_index/>索引</a></li><li><a href=/middleware/docs/mysql/business_facing/innodb_lock/>锁</a></li></ul></li><li><span>高级篇</span><ul><li><a href=/middleware/docs/mysql/advanced/page_lock_log/>底层结构</a></li></ul></li><li><a href=/middleware/docs/mysql/MySQL/>mysql高级总结</a></li><li><a href=/middleware/docs/mysql/mysql2/ class=active>mysql总结</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/middleware/magic.js></script>
<script src=/middleware/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/middleware/svg/menu.svg class=book-icon alt=Menu></label>
<strong>mysql总结</strong>
<label for=toc-control><img src=/middleware/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#0重要的知识点>0.重要的知识点</a></li><li><a href=#表空间的格式>表空间的格式</a><ul><li><a href=#页的结构>页的结构</a><ul><li><a href=#文件管理页>文件管理页</a></li><li><a href=#inode页>INODE页</a></li><li><a href=#index数据索引页>INDEX数据索引页</a></li></ul></li><li><a href=#讨论innodb数据结构>讨论innodb数据结构</a></li><li><a href=#log>log</a></li><li><a href=#mvcc>mvcc</a></li><li><a href=#fqa>FQA</a></li></ul></li></ul></nav></aside></header><article class=markdown><ul><li><a href=/middleware/#0%e9%87%8d%e8%a6%81%e7%9a%84%e7%9f%a5%e8%af%86%e7%82%b9>0.重要的知识点</a></li><li><a href=/middleware/#%e8%a1%a8%e7%a9%ba%e9%97%b4%e7%9a%84%e6%a0%bc%e5%bc%8f>表空间的格式</a><ul><li><a href=/middleware/#%e9%a1%b5%e7%9a%84%e7%bb%93%e6%9e%84>页的结构</a><ul><li><a href=/middleware/#%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86%e9%a1%b5>文件管理页</a></li><li><a href=/middleware/#inode%e9%a1%b5>INODE页</a></li><li><a href=/middleware/#index%e6%95%b0%e6%8d%ae%e7%b4%a2%e5%bc%95%e9%a1%b5>INDEX数据索引页</a><ul><li><a href=/middleware/#%e8%81%9a%e7%b0%87%e5%92%8c%e9%9d%9e%e8%81%9a%e7%b0%87>聚簇和非聚簇</a></li><li><a href=/middleware/#index>index</a><ul><li><a href=/middleware/#row-format>Row Format</a><ul><li><a href=/middleware/#what>what:</a></li><li><a href=/middleware/#what-1>what:</a></li><li><a href=/middleware/#how>how:</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=/middleware/#%e8%ae%a8%e8%ae%bainnodb%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>讨论innodb数据结构</a></li><li><a href=/middleware/#log>log</a></li><li><a href=/middleware/#mvcc>mvcc</a></li><li><a href=/middleware/#fqa>FQA</a></li></ul></li></ul><h1 id=0重要的知识点>0.重要的知识点
<a class=anchor href=#0%e9%87%8d%e8%a6%81%e7%9a%84%e7%9f%a5%e8%af%86%e7%82%b9>#</a></h1><ol><li><p>MySQL逻辑架构
1.1. 连接层
1.2. 服务层
1.3. 引擎层(存储引擎是基于表的，而不是数据库)
1.4. 存储层</p></li><li><p>如何修改字符集(查看1.3)</p></li><li><p>日志
3.1. 查询日志
3.2. 错误日志
3.3. 二进制日志</p></li></ol><ul><li><ol start=4><li>分析慢SQL的步骤</li></ol><ul><li><del>first:找到是那些sql慢.</del><ul><li>4.1. 慢查询的开启，设置阈值(如超过5秒钟的就是慢SQL)并捕获。</li></ul></li><li><del>second:开始分析这些sql.</del><ul><li>4.2. explain + 慢SQL分析。<ul><li>查询语句写的差。<ul><li>关联 查询太多<code>join</code>（设计缺陷或者不得已的需求）。</li></ul></li><li>索引失效：索引建了，但是没有用上。</li></ul></li><li>4.3. show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。</li><li>4.4. MySQL数据库服务器的参数调优。</li></ul></li></ul></li></ul><ol start=5><li>SQL执行顺序</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#66d9ef>select</span>              <span style=color:#75715e># 5 ----&gt;</span>
</span></span><span style=display:flex><span>	... 
</span></span><span style=display:flex><span>from                <span style=color:#75715e># 1</span>
</span></span><span style=display:flex><span>	... 
</span></span><span style=display:flex><span>where               <span style=color:#75715e># 2</span>
</span></span><span style=display:flex><span>	.... 
</span></span><span style=display:flex><span>group by            <span style=color:#75715e># 3</span>
</span></span><span style=display:flex><span>	... 
</span></span><span style=display:flex><span>having              <span style=color:#75715e># 4 ----&gt;</span>
</span></span><span style=display:flex><span>	... 
</span></span><span style=display:flex><span>order by            <span style=color:#75715e># 6</span>
</span></span><span style=display:flex><span>	... 
</span></span><span style=display:flex><span>limit               <span style=color:#75715e># 7</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>[</span>offset<span style=color:#f92672>]</span>
</span></span></code></pre></div><ol start=6><li>join
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201203160509.png alt=如何写出join语句></li></ol><ul><li><ol start=7><li>索引</li></ol><ul><li><p>what:
<a href=https://www.tutorialspoint.com/mysql/mysql-indexes.htm>A database index is a data structure that improves the speed of operations in a table</a></p><ul><li>索引分类：<ul><li>单值索引：一个索引只包含单个列，一个表可以有多个单列索引。</li><li>唯一索引：索引列的值必须唯一，但是允许<strong>空值</strong>。</li><li>复合索引：一个索引包含多个字段。</li></ul></li></ul></li><li><p>why:</p><ul><li>索引的优势和劣势<ul><li>优势：<ul><li>查找：类似大学图书馆的书目索引，提高数据检索的效率，降低数据库的IO成本。</li><li>排序：通过索引対数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li></ul></li><li>劣势：<ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。</li><li>虽然索引大大提高了查询速度，但是同时会降低表的更新速度，例如对表频繁的进行<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>。因为更新表的时候，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li><li>索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引。</li></ul></li></ul></li></ul></li><li><p>how:</p><ul><li><strong>重点：索引会影响到MySQL查找(WHERE的查询条件)和排序(ORDER BY)两大功能！</strong></li><li>什么时候需要建立索引：<ul><li>主键:主键自动建立主键索引（唯一 + 非空）。</li><li>where/order by:<ul><li>频繁作为查询条件的字段应该创建索引。</li><li>查询中统计或者分组字段（group by也和索引有关）。</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。</li></ul></li><li>查询中与其他表关联的字段，<strong>外键关系</strong>建立索引。</li></ul></li><li>索引分析<ul><li>从9.1.单表索引分析&ndash;>范围之后的索引会失效。</li><li>从9.2.两表索引分析&mdash;>左连接将索引创建在右表上更合适。</li><li>10.1.索引失效的情况:<ul><li>全值匹配我最爱。</li><li>最佳左前缀法则。</li><li>不在<strong>索引列</strong>上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。</li><li>索引中<strong>范围条件</strong>右边的字段会全部失效。</li><li>尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少<code>SELECT *</code>。</li><li>MySQL在使用<code>!=</code>或者<code>&lt;></code>的时候无法使用索引会导致全表扫描。</li><li><code>is null</code>、<code>is not null</code>也无法使用索引。</li><li><code>like</code>以通配符开头<code>%abc</code>索引失效会变成全表扫描。</li><li>字符串不加单引号索引失效。</li><li>少用<code>or</code>，用它来连接时会索引失效。</li></ul></li></ul></li></ul></li></ul></li><li><ol start=8><li>锁</li></ol><ul><li>what:<ul><li>InnoDB锁:<ul><li><ol><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li></ol></li><li><ol start=2><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ol></li></ul><blockquote><blockquote><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：</p></blockquote></blockquote><ul><li><ol start=3><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li></ol></li><li><ol start=4><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ol></li></ul></li></ul></li></ul><blockquote><blockquote><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201204193446.png alt=20201204193446>
（如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。）</p></blockquote></blockquote><ul><li>why:<ul><li>防止并发修改数据。</li></ul></li><li>how:<ul><li>InnoDB加锁方法：<ul><li>对于普通<code>SELECT</code>语句，InnoDB 不会加<strong>任何锁</strong>；</li><li>对于 <code>UPDATE、 DELETE 和 INSERT</code> 语句， InnoDB会自动给涉及数据集加<strong>排他锁（X)</strong>；</li><li>事务可以通过以下语句显式给记录集加共享锁或排他锁：<ul><li>共享锁（S）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code>。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li><li>排他锁（X)：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code>。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li></ul></li><li><del>意向锁是 InnoDB 自动加的， 不需用户干预。</del></li></ul></li></ul></li></ul></li></ul><h1 id=表空间的格式>表空间的格式
<a class=anchor href=#%e8%a1%a8%e7%a9%ba%e9%97%b4%e7%9a%84%e6%a0%bc%e5%bc%8f>#</a></h1><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210218140846.png alt=InnoDB的物理结构>
segment和extent是InnoDB内部用于分配管理页的逻辑结构，用于分配与回收页，对于写入数据的性能至关重要。</p><p>但这张图有所局限性，可能会产生误解：</p><p>1）图中是系统表空间，因此存在rollback segment，独立表空间则没有。
2）leaf node segment实际是InnoDB的inode概念，一个segment可能包含最多32个碎片page、0个extent（用于小表优化），或者是非常多的extent，我猜测作者图中画了4个extent是在描述表超过32MB大小的时候一次申请4个extent。
3）一个extent在默认16k的page大小下，由64个page组成，page大小由UNIV_PAGE_SIZE定义，所以extent不一定由64个page组成。</p><p>表的所有行数据都存在页类型为INDEX的索引页（page）上，为了管理表空间，还需要很多其他的辅助页，例如文件管理页FSP_HDR/XDES、插入缓冲IBUF_BITMAP页、INODE页等。</p><h2 id=页的结构>页的结构
<a class=anchor href=#%e9%a1%b5%e7%9a%84%e7%bb%93%e6%9e%84>#</a></h2><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/innodb_files.png alt=innodb_files></p><p>MySQL一次IO的最小单位是页（page），也可以理解为一次原子操作都是以page为单位的，默认大小16k。刚刚列出的所有物理文件结构上都是以Page构成的，只是page内部的结构不同。</p><h3 id=文件管理页>文件管理页
<a class=anchor href=#%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86%e9%a1%b5>#</a></h3><ul><li>文件管理页的页类型是FSP_HDR和XDES（extent descriptor），用于分配、管理extent和page。<ul><li>FSP_HDR和XDES的唯一区别，<ul><li>它们两者除了<code>FSP Header</code>这个位置只在FSP_HDR有值，在XDES中是用0填充的；其他field都一样。都是类似的一堆结构(一个占40字节的XDES entry描述维护extent的)<ul><li><code>FSP Header</code>这个field，它在XDES页中是空的<code>(zero-filled for XDES pages) ---> (112)</code>; page 0(FSP_HDR页面)中FSP_HDR中有值。</li><li>FSP_HDR页都是page 0，XDES页一般出现在page 16384, 32768等固定的位置。一个FSP_HDR或者XDES页大小同样是16K。</li></ul></li></ul></li><li>一般情况下，每个extent都有一个占40字节的XDES entry描述维护，因此1个(FSP_HDR/XDES)页最多管理256个extent（也就是256M，16384个page）。那么随着表空间文件越来越大，就需要更多的XDES页。(所以才会出现在16384, 32768的位置)<ul><li>FSP header:<ul><li>而FSP Header里面最重要的信息就是四个链表头尾数据（FLST_BASE_NODE结构，FLST意思是first and last），FLST_BASE_NODE如下。<ul><li>1）当一个Extent中所有page都未被使用时，挂在FSP_FREE list base node上，可以用于随后的分配；</li><li>2）有一部分page被写入的extent，挂在FREE_FRAG list base node上；</li><li>3）全满的extent，挂在FULL_FRAG list base node上；</li><li>4）归属于某个segment时候挂在FSEG list base node上。</li></ul></li><li><strong>当InnoDB写入数据的时候，会从这些链表上分配或者回收extent和page，这些extent也都是在这几个链表上移动的。</strong></li></ul></li><li>XDES entry<ul><li>XDES entry存储所管理的extent状态：<ul><li>1）FREE（空）</li><li>2）FREE_FRAG（至少一个被占用）</li><li>3）FULL_FRAG（满）</li><li>4）归某个segment管理的信息</li></ul></li><li>XDES entry还存储了每个extent内部page是否free（有空间）信息（用bitmap表示）。XDES entry组成了一个双向链表，同一种extent状态的收尾连在一起，便于管理。</li></ul></li></ul></li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/innodb_file_struct_manager.png alt=innodb_file_struct_manager></p><h3 id=inode页>INODE页
<a class=anchor href=#inode%e9%a1%b5>#</a></h3><ul><li><p>what:</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/innodb_file_struct_inode.png alt=innodb_file_struct_inode></li></ul></li><li><p>why:</p></li><li><p>how:</p><ul><li><p>segment是表空间管理的逻辑单位。INODE页就是用于管理segment的，每个Inode entry负责一个segment。</p><ul><li>一个segment由32个碎片页（fragment array），FSEG_FREE、FSEG_NOT_FULL、FSEG_FULL组成，这些信息记录在Inode entry里，可以简单理解为Inode就是segment元信息的载体。<ul><li>FREE、NOT_FULL、FULL三个FLST_BASE_NODE对象和FSP_HDR/XDES页里面的FSP_FREE、FREE_FRAG、FULL_FRAG、FSEG概念类似。这些链表被InnoDB使用，用于高效的管理页分配和回收。</li><li>至于碎片页上（fragment array），用于优化小表空间分配，先从全局的碎片分配Page，当fragment array填满（32个槽位）时，之后每次分配一个完整的Extent，如果表大于32MB，则一次分配4个extent。</li></ul></li></ul></li><li><p>MySQL的数据是按照B+ tree聚簇索引（clustered index）组织数据的，每个B+ tree使用两个segment来管理page，分别是leaf node segment（叶子节点segment）和non-leaf node segment（非叶子节点segment）。</p><ul><li>这两个segment的Inode entry地址记录在B+ tree的root page中FSEG_HEADER里面，而root page又被分配在non-leaf segment第一个碎片页上（fragment array）。</li></ul></li></ul></li></ul><h3 id=index数据索引页>INDEX数据索引页
<a class=anchor href=#index%e6%95%b0%e6%8d%ae%e7%b4%a2%e5%bc%95%e9%a1%b5>#</a></h3><h4 id=聚簇和非聚簇>聚簇和非聚簇
<a class=anchor href=#%e8%81%9a%e7%b0%87%e5%92%8c%e9%9d%9e%e8%81%9a%e7%b0%87>#</a></h4><ul><li>what:<ul><li>Clustered/Unclustered<ul><li>Clustered<ul><li>Index determines the location of indexed records</li><li>Typically, clustered index is one where values are data records (but not necessary)</li></ul></li><li>Unclustered<ul><li>Index cannot reorder data, does not determine data location</li><li>In these indexes: value = pointer to data record</li></ul></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210218151054.png alt=20210218151054></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210218151136.png alt=20210218151136></li></ul></li></ul></li><li>why:</li><li>how:<ul><li>就是它的实际数据也是按照顺序排的，那么可以向上和向下查找，但是如果是非聚族的，它如果想找比它大一点点的值，你不可能从Data file里面就能找到，你必须回归到Data entries？</li><li>使用B+树聚簇索引（B+ tree clustered index）的好处在于，<ul><li>1）数据和索引顺序一致，充分利用磁盘顺序IO性能普遍高于随机IO的特性。</li><li>2）对于局部性查询也会大有裨益。</li><li>3）采用B+树，叶子节点（leaf node）存储数据，<strong>非叶子节点（non-leaf node）只是索引，这样非叶子节点就会足够的小(一个页面就能存储很多的节点，查找的时候，减少了磁盘io)</strong>，因此数据很“热”，便于更好的缓存。</li><li>4）对于覆盖索引，可以直接利用叶子节点的主键值。</li></ul></li><li>二级索引，就可以理解为非聚簇索引，也是一颗B+树，只不过这棵树的叶子节点是指向聚簇索引主键的，可以看做“行指针”，因此查询的时候需要“回表”。</li></ul></li></ul><h4 id=index>index
<a class=anchor href=#index>#</a></h4><ul><li><p>what:
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/innodb_file_struct_index.png alt=innodb_file_struct_index>
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210218185953.png alt=20210218185953></p><ul><li>主键、二级索引、行和列<ul><li>B+树的**每个节点(包括叶子和非叶子节点)**都是一个INDEX索引页，其结构都是相同的；</li><li>对于聚簇索引，非叶子节点包含主键和child page number，叶子节点包含主键和具体的行；</li><li>对于非聚簇索引，也就是二级索引，非叶子节点包含二级索引和child page number，叶子节点包含二级索引和主键值。</li></ul></li><li>叶子和非叶子都在index索引页，那么inode里面保存的segment信息，是不是这个segment用的所有页都能从这里找到，（先用的32个碎片页，然后也能从管理页中申请extent?）</li></ul></li><li><p>why:</p></li><li><p>how:</p><ul><li>page directory从Fil Trailer开始从后往前写，里面包含槽位slots，每个slot 2个字节，存储了某些record在该页中的物理偏移量，例如图中最后面是infimum record的offset，最前面是supremum record的offset，中间从后往前是r4，r8，r12 record的offset，一般总是每隔4-8个record添加一个slot，这样slots就等同于一个稀疏索引（sparse index），加速页内查询的办法就是通过二分查找，查询key的时间复杂度可以降为O(logN)，由于页都在内存里面，所以查询性能可控，内存访问延迟100ns左右，如果在CPU缓存中则可能更快。</li></ul></li></ul><h5 id=row-format>Row Format
<a class=anchor href=#row-format>#</a></h5><h6 id=what>what:
<a class=anchor href=#what>#</a></h6><p>row format可通过innodb_default_row_format参数指定，也可以在建表的时候指定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> choose_row_format (
</span></span><span style=display:flex><span>   id INT,
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB ROW_FORMAT<span style=color:#f92672>=</span><span style=color:#66d9ef>DYNAMIC</span>;
</span></span></code></pre></div><ul><li>REDUNDANT: 是比较老的格式，</li><li>COMPACT: 5.6版本默认，COMPACT比REDUNDANT要更节省空间，大概在20%左右。</li><li>DYNAMIC: 5.7版本默认，DYNAMIC在变长存储上做了更大的空间优化，对于VARBINARY, VARCHAR, BLOB和TEXT类型更友好，</li><li>COMPRESSED是压缩页。</li></ul><h6 id=what-1>what:
<a class=anchor href=#what-1>#</a></h6><h6 id=how>how:
<a class=anchor href=#how>#</a></h6><blockquote><p>row的格式在上面图中简单介绍过，由可选的两个标识+record header+body组成，具体如下。</p></blockquote><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/innodb_file_struct_row_record.png alt=innodb_file_struct_row_record></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210218190555.png alt=20210218190555></p><p>4）索引：序列化后存储于此，例如int类型索引主键就占用4个字节。
对于聚簇索引的叶子节点，存储行。
对于二级索引的叶子节点，存储行的主键值。
对于聚簇索引和二级索引的非叶子节点，存储child page最小的key。
上面提到的infimum和supremum中就只存字符串在行数据里。</p><p><a href=https://courses.cs.washington.edu/courses/cse444/09sp/lectures/lecture15.pdf>ppt</a>
<a href=http://neoremind.com/2020/01/inside_innodb_file/>blog</a></p><h2 id=讨论innodb数据结构>讨论innodb数据结构
<a class=anchor href=#%e8%ae%a8%e8%ae%bainnodb%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><ul><li><a href=https://zhuanlan.zhihu.com/p/113917726>索引最终选择B+树的原因</a>:<ul><li>1，范围查询，2，减少磁盘IO<ul><li>减少IO的次数，每次读取尽可能多的数据.<ul><li>因为B+树非叶子节点没有数据，可以存储更多的节点或者叫索引数据，比B树更加矮胖，可以更快的定位到叶子节点，自然就减少了磁盘IO的次数。</li></ul></li><li>如果范围数据左右子树都有<ul><li>B+树的数据结构特点是：数据都在叶子节点，而叶子节点又是通过指针相连，是有序链表.</li></ul></li></ul></li></ul></li><li>hash很快，但每次IO只能取一个数(范围查找不适合);<ul><li>哈希索引只需要计算一次就可以获取到对应的数据，检索速度非常快。但是 Mysql 并没有采取哈希作为其底层算法，这是为什么呢？因为考虑到数据检索有一个常用手段就是范围查找，比如以下这个 SQL 语句：<code>select \* from user where id \>3;</code>针对以上这个语句，我们希望做的是找出 id>3 的数据，这是很典型的范围查找。如果使用哈希算法实现的索引，范围查找怎么做呢？一个简单的思路就是一次把所有数据找出来加载到内存，然后再在内存里筛选筛选目标范围内的数据。但是这个范围查找的方法也太笨重了，没有一点效率而言。<ul><li>所以，使用哈希算法实现的索引虽然可以做到快速检索数据，但是没办法做数据高效范围查找，因此哈希索引是不适合作为 Mysql 的底层索引的数据结构。</li></ul></li></ul></li><li>AVL和红黑树，在大量数据的情况下，IO操作还是太多;</li><li>B树每个节点内存储的是数据，因此每个节点存储的分支太少;</li><li>B+节点存储的是索引+指针(引用指向下一个节点)，可以存储大量索引，同时最终<ul><li><ol><li><strong>非叶子节点没有数据;数据存储在叶子节点</strong>.</li></ol></li><li><ol start=2><li><strong>并且有引用横向链接</strong>，可以在2-3次的IO操作内完成千万级别的表操作;</li></ol></li></ul></li><li>建议索引是是自增长数字，这样适合范围查找.</li></ul><h2 id=log>log
<a class=anchor href=#log>#</a></h2><ul><li><p>log</p><ul><li><p>redo log</p><ul><li>what:<ul><li><strong>物理格式</strong>日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</li></ul></li><li>why:<ul><li>确保事务的持久性。</li><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</li></ul></li><li>how:<ul><li>什么时候产生：<ul><li>事务开始之后就产生<code>redo log</code>，<code>redo log</code>的落盘并不是当事务提交时才写入的，而是在事务的执行过程中，便开始写入<code>redo log</code>文件中。<ul><li>重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。</li><li>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘<ul><li><ol><li>Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</li></ol></li><li><ol start=2><li>每个事务提交时会将重做日志刷新到重做日志文件。</li></ol></li><li><ol start=3><li>当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件</li></ol></li></ul></li></ul></li></ul></li><li>什么时候释放：<ul><li>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</li></ul></li><li>对应的物理文件：<ul><li>默认情况下，对应的物理文件位于数据库的data目录下的<code>ib_logfile1&ib_logfile2</code><ul><li>innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。</li><li>innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2</li></ul></li><li>关于文件的大小和数量，由一下两个参数配置<ul><li>innodb_log_file_size 重做日志文件的大小。</li><li>innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</li></ul></li></ul></li></ul></li></ul></li><li><p>undo log回滚日志</p><ul><li>what:<ul><li><strong>逻辑格式</strong>的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，<strong>而不是从物理页面上操作实现</strong>的，这一点是不同于redo log的。</li></ul></li><li>why:<ul><li>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</li></ul></li><li>how:<ul><li>什么时候产生：<ul><li>事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</li></ul></li><li>什么时候释放：<ul><li>当事务提交之后，undo log并不能立马被删除，</li><li>而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</li></ul></li><li>对应的物理文件：<ul><li>MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。</li><li>MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</li><li>关于MySQL5.7之后的独立undo 表空间配置参数如下<ul><li>innodb_undo_directory = /data/undospace/ &ndash;undo独立表空间的存放目录</li><li>innodb_undo_logs = 128 &ndash;回滚段为128KB</li><li>innodb_undo_tablespaces = 4 &ndash;指定有4个undo log文件</li></ul></li><li>如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。</li></ul></li><li>其他：<ul><li>undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。</li><li>默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。</li><li>因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的.mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</li></ul></li></ul></li></ul></li><li><p>binlog二进制日志</p><ul><li>what:<ul><li>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</li><li>在使用mysqlbinlog解析binlog之后一些都会真相大白。</li></ul></li><li>why:<ul><li><ol><li>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</li></ol></li><li><ol start=2><li>用于数据库的基于时间点的还原。</li></ol></li></ul></li><li>how:<ul><li>什么时候产生：<ul><li>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</li><li>这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</li><li>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。<ul><li>这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</li></ul></li></ul></li><li>什么时候释放：<ul><li>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</li></ul></li><li>对应的物理文件：<ul><li>配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</li><li>对于每个binlog日志文件，通过一个统一的index文件来组织。</li></ul></li><li>二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同<ul><li><ol><li>作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</li></ol></li><li><ol start=2><li>内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</li></ol></li><li><ol start=3><li>另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</li></ol></li><li><ol start=4><li>恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</li></ol></li></ul></li></ul></li></ul></li></ul></li><li><p>MySQL通过<strong>两阶段提交</strong>过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p></li></ul><p><a href=https://www.cnblogs.com/wy123/p/8365234.html>https://www.cnblogs.com/wy123/p/8365234.html</a></p><h2 id=mvcc>mvcc
<a class=anchor href=#mvcc>#</a></h2><p>mvcc(Multi-Version Concurrency Control) &mdash; Lock-Based Concurrency Control</p><ul><li>what:</li></ul><table><thead><tr><th>\</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>1</td><td>1</td><td>1</td></tr><tr><td>READ COMMITTED</td><td>0</td><td>1</td><td>1</td></tr><tr><td>REPEATABLE READ</td><td>0</td><td>0</td><td>1</td></tr><tr><td>SERIALIZABLE</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><ul><li><p>MySQL的实现：MySQL默认采用RR隔离级别，SQL标准是要求RR解决不可重复读的问题，但是因为MySQL采用了gap lock，所以实际上MySQL的RR隔离级别也解决了幻读的问题。</p><ul><li><ol><li>脏读的情况：对于两个事务T1与T2，T1读取了已经被T2更新但是还没有提交的字段之后，若此时T2回滚，T1读取的内容就是临时并且无效的</li></ol></li><li><ol start=2><li>不可重复读: 对于两个事务T1和T2，T1读取了一个字段，然后T2更新了该字段并提交之后，T1再次提取同一个字段，值便不相等了。</li></ol></li><li><ol start=3><li>幻读: 对于两个事务T1、T2，T1从表中读取数据，然后T2进行了INSERT操作并提交，当T1&rsquo;再次读取的时候，结果不一致的情况发生。</li></ol></li></ul></li><li><p>why:</p></li><li><p>how:</p><ul><li><strong>隔离级别有关的加锁操作</strong><ul><li>在Serializable隔离级别下，所有的操作都会加锁<ul><li>在Serializable隔离级别下，无论是查询语句也会加锁，也就是说快照读不存在了，MVCC降级为Lock-Based CC。</li></ul></li><li>在RC，RR隔离级别下, 对于查询语句（比如<code>select * from T1 where id = 10</code>）来说，都是快照读，不加锁。<ul><li><strong>当前读</strong><ul><li>next-key锁(行记录锁+Gap间隙锁)<ul><li>记录锁（Record Lock）：<ul><li>记录锁锁定索引中的一条记录。</li></ul></li><li>间隙锁（Gap Lock）：<ul><li>间隙锁要么锁住索引记录之间的值，要么锁住第一个索引记录前面的值或最后一个索引记录后面的值。</li></ul></li><li>Next-Key Lock：<ul><li>索引记录上的记录锁和在记录之前的间隙锁的组合。</li><li>next-key锁(行记录锁+Gap间隙锁)</li></ul></li></ul></li><li>触发动作<ul><li>对主键或唯一索引，如果当前读时，where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁。</li><li>非唯一索引列，如果where条件部分命中(>、&lt;、like等)或者全未命中，则会加附近Gap间隙锁。例如，某表数据如下，非唯一索引2,6,9,9,11,15。如下语句要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11]，该区间内无法插入数据。</li><li>没有索引的列，当前读操作时，会加全表gap锁，生产环境要注意。</li></ul></li></ul></li><li><strong>快照读</strong><ul><li>单纯的select操作，不包括上述 select &mldr; lock in share mode, select &mldr; for update。</li><li>Read Committed隔离级别：每次select都生成一个快照读。&mdash;>TODO 这里应该是开始确定一个快照ID吧</li><li>Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。&mdash;>TODO 这里应该是开始确定一个快照ID吧<ul><li>下图右侧绿色的是数据：一行数据记录，<code>主键ID是10，name='Jack'，age=10,</code> 被update更新set为<code>name= 'Tom'，age=23。</code><ul><li>事务会先使用“排他锁”锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务的DB_TRX_ID，使用回滚指针DB_ROLL_PTR指向undo log中修改前的行DB_ROW_ID。</li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210219150303.png alt=20210219150303><ul><li>DB_TRX_ID: 6字节DB_TRX_ID字段，表示最后更新的事务id(update,delete,insert)。此外，删除在内部被视为更新，其中行中的特殊位被设置为将其标记为已软删除。</li><li>DB_ROLL_PTR: 7字节回滚指针，指向前一个版本的undolog记录，组成undo链表。如果更新了行，则撤消日志记录包含在更新行之前重建行内容所需的信息。</li><li>DB_ROW_ID: 6字节的DB_ROW_ID字段，包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。如果表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 聚簇索引会使用DB_ROW_ID的值来作为主键; 如果表中有主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID了 。</li></ul></li><li><code>insert undo log</code>只在事务回滚时需要,事务提交就可以删掉了。<code>update undo log</code>包括<code>update</code> 和 <code>delete</code>, 回滚和快照读都需要。</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id=fqa>FQA
<a class=anchor href=#fqa>#</a></h2><ul><li><a href=/middleware/>如何锁住一个范围</a></li></ul><ol><li>数据库事务ACID特性
数据库事务的4个特性：</li></ol><p>原子性(Atomic): 事务中的多个操作，不可分割，要么都成功，要么都失败； All or Nothing.</p><p>一致性(Consistency): 事务操作之后, 数据库所处的状态和业务规则是一致的; 比如a,b账户相互转账之后，总金额不变；</p><p>隔离性(Isolation): 多个事务之间就像是串行执行一样，不相互影响;</p><p>持久性(Durability): 事务提交后被持久化到永久存储.</p><p><a href=https://www.cnblogs.com/kisun168/p/11320549.html>https://www.cnblogs.com/kisun168/p/11320549.html</a>
<a href=https://zhuanlan.zhihu.com/p/161933980>https://zhuanlan.zhihu.com/p/161933980</a></p><ol start=5><li>MySQL 中RC和RR隔离级别的区别
MySQL数据库中默认隔离级别为RR，但是实际情况是使用RC 和 RR隔离级别的都不少。好像淘宝、网易都是使用的 RC 隔离级别。那么在MySQL中 RC 和 RR有什么区别呢？我们该如何选择呢？为什么MySQL将RR作为默认的隔离级别呢？</li></ol><p>5.1 RC 与 RR 在锁方面的区别
1> 显然 RR 支持 gap lock(next-key lock)，而RC则没有gap lock。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR；</p><p>2> RC 隔离级别，通过 where 条件过滤之后，不符合条件的记录上的行锁，会释放掉(虽然这里破坏了“两阶段加锁原则”)；但是RR隔离级别，即使不符合where条件的记录，也不会是否行锁和gap lock；所以从锁方面来看，RC的并发应该要好于RR；另外 insert into t select &mldr; from s where 语句在s表上的锁也是不一样的。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#0重要的知识点>0.重要的知识点</a></li><li><a href=#表空间的格式>表空间的格式</a><ul><li><a href=#页的结构>页的结构</a><ul><li><a href=#文件管理页>文件管理页</a></li><li><a href=#inode页>INODE页</a></li><li><a href=#index数据索引页>INDEX数据索引页</a></li></ul></li><li><a href=#讨论innodb数据结构>讨论innodb数据结构</a></li><li><a href=#log>log</a></li><li><a href=#mvcc>mvcc</a></li><li><a href=#fqa>FQA</a></li></ul></li></ul></nav></div></aside></main></body></html>