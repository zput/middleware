<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Golang基本用法 # Golang基本用法 数据结构 string 单引号 slice和数组的异同 slice的自动扩容后的大小是多少? 延伸 map 哈希扩容 扩容规则 struct和内存对齐 chan error.Unwrap 跟类型相关 类型系统 跟函数定义的结构相关 函数调用栈细节 闭包 方法(method) defer三阶段 before 1.13 测试题 1.13 1.14 panic AND recover 测验 跟interface相关 接口 eface iface 类型断言 reflect reflect.Type reflect.Value 运行时: 并发编程 同步原语 内存顺序保证 sync包 context(上下文) 内存管理 GC 逃逸分析 内存泄漏 附录 0.方法 1. new And make example 2. 值类型和引用类型的区别 3. 计算golang中类型的大小的方式 golang的chan archive 数据结构 # 这些数据结构的底层是怎么实现的,比如array,它就是一个指针,指向第一个元素的地址. 然后就是一个细节,如果要实现这个数据结构的一些功能,比如chan读写,map的添加删除等,它们是怎么利用数据结构里面底层的field来实现这些功能? string # string类型的底层结构.它的大小是几个字节?"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="基本用法"><meta property="og:description" content="Golang基本用法 # Golang基本用法 数据结构 string 单引号 slice和数组的异同 slice的自动扩容后的大小是多少? 延伸 map 哈希扩容 扩容规则 struct和内存对齐 chan error.Unwrap 跟类型相关 类型系统 跟函数定义的结构相关 函数调用栈细节 闭包 方法(method) defer三阶段 before 1.13 测试题 1.13 1.14 panic AND recover 测验 跟interface相关 接口 eface iface 类型断言 reflect reflect.Type reflect.Value 运行时: 并发编程 同步原语 内存顺序保证 sync包 context(上下文) 内存管理 GC 逃逸分析 内存泄漏 附录 0.方法 1. new And make example 2. 值类型和引用类型的区别 3. 计算golang中类型的大小的方式 golang的chan archive 数据结构 # 这些数据结构的底层是怎么实现的,比如array,它就是一个指针,指向第一个元素的地址. 然后就是一个细节,如果要实现这个数据结构的一些功能,比如chan读写,map的添加删除等,它们是怎么利用数据结构里面底层的field来实现这些功能? string # string类型的底层结构.它的大小是几个字节?"><meta property="og:type" content="article"><meta property="og:url" content="https://zput.github.io/go-goroutine/docs/foundation/golang_basic/"><meta property="article:section" content="docs"><title>基本用法 | go调度源码分析</title><link rel=manifest href=/go-goroutine/manifest.json><link rel=icon href=/go-goroutine/favicon.png type=image/x-icon><link rel=stylesheet href=/go-goroutine/book.min.76f6dbe75c94e688c018dd8b54e7f880916b14ab4cf3881b81f75d6bb916603c.css integrity="sha256-dvbb51yU5ojAGN2LVOf4gJFrFKtM84gbgfdda7kWYDw=" crossorigin=anonymous><script defer src=/go-goroutine/flexsearch.min.js></script>
<script defer src=/go-goroutine/en.search.min.75f3025a21511955ad10f181cae208dd296ce24ee2a06def487a11decfa675f1.js integrity="sha256-dfMCWiFRGVWtEPGByuII3Sls4k7ioG3vSHoR3s+mdfE=" crossorigin=anonymous></script>
<script defer src=/go-goroutine/sw.min.ec96d6e09af3075a94dd4de723a2edddf2ef138381c7e1e5b5a1f2c0578ee8bd.js integrity="sha256-7JbW4JrzB1qU3U3nI6Lt3fLvE4OBx+HltaHywFeO6L0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/go-goroutine/><span>go调度源码分析</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><div class=book-switch><label class=switch><input id=dark-mode-checkbox type=checkbox onchange=darkmode()>
<span class=slider></span></label></div></div><ul><li><a href=https://zput.github.io target=_blank rel=noopener>Zput博客</a></li><li><a href=https://github.com/zput target=_blank rel=noopener>GitHub</a></li></ul><hr><ul><li><span>基础知识</span><ul><li><a href=/go-goroutine/docs/foundation/golang_basic/ class=active>基本用法</a></li></ul></li><li><span>鲁棒和性能</span><ul><li><a href=/go-goroutine/docs/robustness_and_performance/golang_test/>测试相关函数</a></li></ul></li><li><span>运行时</span><ul><li><a href=/go-goroutine/docs/runtime/golang_gmp/>GMP</a></li><li><a href=/go-goroutine/docs/runtime/golang_gc/>垃圾回收</a></li><li><a href=/go-goroutine/docs/runtime/schedule/>调度</a><ul><li><span>前置知识</span><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/memory/>内存大小端</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/register_functionstack/>伪寄存器与函数栈帧</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/similar_assemble/>类汇编</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch0-preknowledge/go_underlying_struct/>底层重要结构</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/2_init_before_enter_main_function/>初始化</a></li><li><a href=/go-goroutine/docs/runtime/schedule/3_exit_goroutine/>退出</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/>调度挑选策略</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/take_goroutine_from_globalorlocal_p/>从全局/本P队列</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch1-scheduling_selection_strategy/steal_goroutine_from_other_p/>从其他P队列</a></li></ul></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/>调度到达时机</a><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/active_scheduling/>主动调度</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/passive_scheduling/>被动调度</a></li><li><input type=checkbox id=section-99f41010918d678e89a7af90330cabe1 class=toggle>
<label for=section-99f41010918d678e89a7af90330cabe1 class="flex justify-between"><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/>剥夺调度</a></label><ul><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/start_sysmon/>开启系统监控</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/user_code_preemption/>执行太久</a></li><li><a href=/go-goroutine/docs/runtime/schedule/ch2-Scheduling_arrival_time/deprivation_of_scheduling/system_call_preemption/>系统调用抢占</a></li></ul></li></ul></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script><script src=/go-goroutine/magic.js></script>
<script src=/go-goroutine/dark.js></script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/go-goroutine/svg/menu.svg class=book-icon alt=Menu></label>
<strong>基本用法</strong>
<label for=toc-control><img src=/go-goroutine/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#golang基本用法>Golang基本用法</a><ul><li><a href=#数据结构>数据结构</a><ul><li><a href=#string>string</a></li><li><a href=#slice和数组的异同>slice和数组的异同</a></li><li><a href=#map>map</a></li><li><a href=#struct和内存对齐>struct和内存对齐</a></li><li><a href=#chan>chan</a></li><li><a href=#errorunwrap>error.Unwrap</a></li></ul></li><li><a href=#跟类型相关>跟类型相关</a><ul><li><a href=#类型系统>类型系统</a></li><li><a href=#跟函数定义的结构相关>跟函数定义的结构相关</a></li><li><a href=#跟interface相关>跟interface相关</a></li></ul></li><li><a href=#运行时>运行时:</a><ul><li><a href=#并发编程>并发编程</a></li><li><a href=#内存管理>内存管理</a></li></ul></li><li><a href=#附录>附录</a><ul><li><a href=#0方法>0.方法</a></li><li><a href=#1-new-and-make>1. new And make</a></li><li><a href=#2-值类型和引用类型的区别>2. 值类型和引用类型的区别</a></li><li><a href=#3-计算golang中类型的大小的方式>3. 计算golang中类型的大小的方式</a></li><li><a href=#golang的chan>golang的chan</a></li></ul></li><li><a href=#archive>archive</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=golang基本用法>Golang基本用法
<a class=anchor href=#golang%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95>#</a></h1><ul><li><a href=/go-goroutine/#golang%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95>Golang基本用法</a><ul><li><a href=/go-goroutine/#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>数据结构</a><ul><li><a href=/go-goroutine/#string>string</a><ul><li><a href=/go-goroutine/#%e5%8d%95%e5%bc%95%e5%8f%b7>单引号</a></li></ul></li><li><a href=/go-goroutine/#slice%e5%92%8c%e6%95%b0%e7%bb%84%e7%9a%84%e5%bc%82%e5%90%8c>slice和数组的异同</a><ul><li><a href=/go-goroutine/#slice%e7%9a%84%e8%87%aa%e5%8a%a8%e6%89%a9%e5%ae%b9%e5%90%8e%e7%9a%84%e5%a4%a7%e5%b0%8f%e6%98%af%e5%a4%9a%e5%b0%91>slice的自动扩容后的大小是多少?</a></li><li><a href=/go-goroutine/#%e5%bb%b6%e4%bc%b8>延伸</a></li></ul></li><li><a href=/go-goroutine/#map>map</a><ul><li><a href=/go-goroutine/#%e5%93%88%e5%b8%8c%e6%89%a9%e5%ae%b9>哈希扩容</a></li><li><a href=/go-goroutine/#%e6%89%a9%e5%ae%b9%e8%a7%84%e5%88%99>扩容规则</a></li></ul></li><li><a href=/go-goroutine/#struct%e5%92%8c%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90>struct和内存对齐</a></li><li><a href=/go-goroutine/#chan>chan</a></li><li><a href=/go-goroutine/#errorunwrap>error.Unwrap</a></li></ul></li><li><a href=/go-goroutine/#%e8%b7%9f%e7%b1%bb%e5%9e%8b%e7%9b%b8%e5%85%b3>跟类型相关</a><ul><li><a href=/go-goroutine/#%e7%b1%bb%e5%9e%8b%e7%b3%bb%e7%bb%9f>类型系统</a></li><li><a href=/go-goroutine/#%e8%b7%9f%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89%e7%9a%84%e7%bb%93%e6%9e%84%e7%9b%b8%e5%85%b3>跟函数定义的结构相关</a><ul><li><a href=/go-goroutine/#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e6%a0%88%e7%bb%86%e8%8a%82>函数调用栈细节</a></li><li><a href=/go-goroutine/#%e9%97%ad%e5%8c%85>闭包</a></li><li><a href=/go-goroutine/#%e6%96%b9%e6%b3%95method>方法(method)</a></li><li><a href=/go-goroutine/#defer%e4%b8%89%e9%98%b6%e6%ae%b5>defer三阶段</a><ul><li><a href=/go-goroutine/#before-113>before 1.13</a><ul><li><a href=/go-goroutine/#%e6%b5%8b%e8%af%95%e9%a2%98>测试题</a></li></ul></li><li><a href=/go-goroutine/#113>1.13</a></li><li><a href=/go-goroutine/#114>1.14</a></li></ul></li><li><a href=/go-goroutine/#panic-and-recover>panic AND recover</a><ul><li><a href=/go-goroutine/#%e6%b5%8b%e9%aa%8c>测验</a></li></ul></li></ul></li><li><a href=/go-goroutine/#%e8%b7%9finterface%e7%9b%b8%e5%85%b3>跟interface相关</a><ul><li><a href=/go-goroutine/#%e6%8e%a5%e5%8f%a3>接口</a><ul><li><a href=/go-goroutine/#eface>eface</a></li><li><a href=/go-goroutine/#iface>iface</a></li></ul></li><li><a href=/go-goroutine/#%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80>类型断言</a></li><li><a href=/go-goroutine/#reflect>reflect</a><ul><li><a href=/go-goroutine/#reflecttype>reflect.Type</a></li><li><a href=/go-goroutine/#reflectvalue>reflect.Value</a></li></ul></li></ul></li></ul></li><li><a href=/go-goroutine/#%e8%bf%90%e8%a1%8c%e6%97%b6>运行时:</a><ul><li><a href=/go-goroutine/#%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b>并发编程</a><ul><li><a href=/go-goroutine/#%e5%90%8c%e6%ad%a5%e5%8e%9f%e8%af%ad>同步原语</a><ul><li><a href=/go-goroutine/#%e5%86%85%e5%ad%98%e9%a1%ba%e5%ba%8f%e4%bf%9d%e8%af%81>内存顺序保证</a></li><li><a href=/go-goroutine/#sync%e5%8c%85>sync包</a></li></ul></li><li><a href=/go-goroutine/#context%e4%b8%8a%e4%b8%8b%e6%96%87>context(上下文)</a></li></ul></li><li><a href=/go-goroutine/#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86>内存管理</a><ul><li><a href=/go-goroutine/#gc>GC</a></li><li><a href=/go-goroutine/#%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90>逃逸分析</a></li><li><a href=/go-goroutine/#%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f>内存泄漏</a></li></ul></li></ul></li><li><a href=/go-goroutine/#%e9%99%84%e5%bd%95>附录</a><ul><li><a href=/go-goroutine/#0%e6%96%b9%e6%b3%95>0.方法</a></li><li><a href=/go-goroutine/#1-new-and-make>1. new And make</a><ul><li><a href=/go-goroutine/#example>example</a></li></ul></li><li><a href=/go-goroutine/#2-%e5%80%bc%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8c%ba%e5%88%ab>2. 值类型和引用类型的区别</a></li><li><a href=/go-goroutine/#3-%e8%ae%a1%e7%ae%97golang%e4%b8%ad%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%a4%a7%e5%b0%8f%e7%9a%84%e6%96%b9%e5%bc%8f>3. 计算golang中类型的大小的方式</a></li><li><a href=/go-goroutine/#golang%e7%9a%84chan>golang的chan</a></li></ul></li><li><a href=/go-goroutine/#archive>archive</a></li></ul></li></ul><h2 id=数据结构>数据结构
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><ul><li>这些数据结构的底层是怎么实现的,比如array,它就是一个指针,指向第一个元素的地址.</li><li>然后就是一个细节,如果要实现这个数据结构的一些功能,比如chan读写,map的添加删除等,它们是怎么利用数据结构里面底层的field来实现这些功能?</li></ul><hr><h3 id=string>string
<a class=anchor href=#string>#</a></h3><p>string类型的底层结构.它的大小是几个字节?</p><p>指针和字节大小</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130201754.png alt=UTF-8></p><pre tabindex=0><code>0xxxxxxx
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;reflect&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;unicode/utf8&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>String2Bytes</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) []<span style=color:#66d9ef>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sh</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>StringHeader</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bh</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>SliceHeader</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Data</span>: <span style=color:#a6e22e>sh</span>.<span style=color:#a6e22e>Data</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Len</span>:  <span style=color:#a6e22e>sh</span>.<span style=color:#a6e22e>Len</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Cap</span>:  <span style=color:#a6e22e>sh</span>.<span style=color:#a6e22e>Len</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span>[]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>bh</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Bytes2String</span>(<span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>string</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>str</span> = <span style=color:#e6db74>&#34;hello 就是&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;---&gt;&#34;</span>, len(<span style=color:#a6e22e>str</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;---&gt;&#34;</span>, len([]rune(<span style=color:#a6e22e>str</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 报错cannot convert str (type string) to type []int64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//fmt.Println(&#34;---&gt;&#34;, len([]int64(str)))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//golang中的unicode/utf8包提供了用utf-8获取长度的方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;RuneCountInString:&#34;</span>, <span style=color:#a6e22e>utf8</span>.<span style=color:#a6e22e>RuneCountInString</span>(<span style=color:#a6e22e>str</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>string 的底层就是uint8的数组指针+长度
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>预期想得到一个字符串的长度而不是字符串底层占得字节长度：
</span></span></span><span style=display:flex><span><span style=color:#75715e>  1。 utf8.RuneCountInString()函数
</span></span></span><span style=display:flex><span><span style=color:#75715e>  2。 []rune(stringxxx) or []int32(stringxxx)
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><ul><li><a href=https://leetcode-cn.com/problems/reverse-vowels-of-a-string/>345. 反转字符串中的元音字母</a></li></ul><hr><h4 id=单引号>单引号
<a class=anchor href=#%e5%8d%95%e5%bc%95%e5%8f%b7>#</a></h4><p>单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;reflect&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//String in double quotes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;tit\nfor\ttat&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Priting String in Double Quotes:&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;x is: %s\n&#34;</span>, <span style=color:#a6e22e>x</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//String in back quotes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>`tit\nfor\ttat`</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;\nPriting String in Back Quotes:&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;y is: %s\n&#34;</span>, <span style=color:#a6e22e>y</span>)
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Declaring a byte with single quotes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>byte</span> = <span style=color:#e6db74>&#39;a&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;\nPriting Byte:&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Print Size, Type and Character
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Size: %d\nType: %s\nCharacter: %c\n&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Declaring a rune with single quotes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#39;£&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;\nPriting Rune:&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Print Size, Type, CodePoint and Character
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Size: %d\nType: %s\nUnicode CodePoint: %U\nCharacter: %c\n&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>r</span>), <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>r</span>), <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Below will raise a compiler error - invalid character literal (more than one character)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//r = &#39;ab&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li><a href=https://golangbyexample.com/double-single-back-quotes-go/>https://golangbyexample.com/double-single-back-quotes-go/</a></li></ul><hr><h3 id=slice和数组的异同>slice和数组的异同
<a class=anchor href=#slice%e5%92%8c%e6%95%b0%e7%bb%84%e7%9a%84%e5%bc%82%e5%90%8c>#</a></h3><p>Go中有两种取子切片的语法形式（假设baseContainer是一个切片或者数组）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>baseContainer</span>[<span style=color:#a6e22e>low</span> : <span style=color:#a6e22e>high</span>]       <span style=color:#75715e>// 双下标形式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>baseContainer</span>[<span style=color:#a6e22e>low</span> : <span style=color:#a6e22e>high</span> : <span style=color:#a6e22e>max</span>] <span style=color:#75715e>// 三下标形式
</span></span></span></code></pre></div><p>上面所示的双下标形式等价于下面的三下标形式：<code>baseContainer[low : high : cap(baseContainer)]</code></p><p>子切片表达式的结果切片的长度为high - low、容量为max - low。</p><p>golang数组是一个指向数组头地址的指针,但是如果你引用超过数组的长度,它会编译不通过.</p><ul><li>如果使用reflect来<code>reflect.ValueOf(array).Index(out_of_range_index)</code>它会在运行时panic(我猜时因为interface{}中_type的类型指明数组的大小是多少,所以会有一个判断.)<ul><li><a href=https://github.com/golang/go/blob/642329fdd55aabafc67b3a7c50902e29125621ab/src/runtime/type.go#L403>type arraytype struct</a></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>arraytype</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typ</span>   <span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>elem</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>slice</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>len</span>   <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h4 id=slice的自动扩容后的大小是多少>slice的自动扩容后的大小是多少?
<a class=anchor href=#slice%e7%9a%84%e8%87%aa%e5%8a%a8%e6%89%a9%e5%ae%b9%e5%90%8e%e7%9a%84%e5%a4%a7%e5%b0%8f%e6%98%af%e5%a4%9a%e5%b0%91>#</a></h4><p>分三步来判断:</p><pre tabindex=0><code>var newCap int

if oldCap*2&lt;nowNeedCap{
	newCap = nowNeedCap
}else{
	if oldCap&lt;1024 {
		newCap =oldCap*2
	}else{
		newCap =oldCap*1.25
	}
}

realNewCap := compare(内存管理模块的细分大小, newCap*EveryElementSize)
</code></pre><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130203140.png alt=20210130203140></p><hr><h4 id=延伸>延伸
<a class=anchor href=#%e5%bb%b6%e4%bc%b8>#</a></h4><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130203237.png alt=20210130203237></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130203436.png alt=20210130203436></p><hr><h3 id=map>map
<a class=anchor href=#map>#</a></h3><ul><li>map的底层是哈希表<ul><li>哈希表的得到buctet的位置一般通过取模,与运算法<ul><li>hash%m</li><li>hash&(m-1) //其中m一定要是2的整数倍,然后它减一,才会使它的后面的值都是1.否则就会导致低位buctet不会被选中的情况.</li></ul></li><li>哈希冲突<ul><li>开放寻址法</li><li>拉链法<ul><li>跳表</li><li>建立新bucket,慢慢迁移到新bucket.</li></ul></li></ul></li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130215651.png alt=20210130215651></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130215740.png alt=20210130215740></p><hr><h4 id=哈希扩容>哈希扩容
<a class=anchor href=#%e5%93%88%e5%b8%8c%e6%89%a9%e5%ae%b9>#</a></h4><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130220033.png alt=20210130220033></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130220422.png alt=20210130220422></p><hr><h4 id=扩容规则>扩容规则
<a class=anchor href=#%e6%89%a9%e5%ae%b9%e8%a7%84%e5%88%99>#</a></h4><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130220816.png alt=20210130220816></p><h3 id=struct和内存对齐>struct和内存对齐
<a class=anchor href=#struct%e5%92%8c%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90>#</a></h3><ul><li><p>懂得内存为什么要对齐,如果不对齐会怎么样?</p><ul><li>不对齐,可能从内存中读一个数据需要读两次,因为总线的原因</li></ul></li><li><p>所以看一个类型的内存对齐,总的原则是不要读两次,尽量不要浪费内存.</p><ul><li>比如32位(4byte) 下:<ul><li>小于4byte的类型以他们自己的类型长度为内存对齐.</li><li>大于等于4byte以4byte.<ul><li>一个struct类型,他的内存对齐为里面field中最大的那个.</li></ul></li></ul></li></ul></li><li><p>判断一个struct在内存中占用的字节数,</p><ul><li>先按照它的各个field以struct的开始地址作为0,开始一个个排好,</li><li>最后要符合这个struct类型的内存对齐.</li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210130214502.png alt=20210130214502></p><ul><li>test</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T1</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f1</span> <span style=color:#66d9ef>int8</span>  <span style=color:#75715e>// 1 byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>f2</span> <span style=color:#66d9ef>int64</span> <span style=color:#75715e>// 8 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>f3</span> <span style=color:#66d9ef>int32</span> <span style=color:#75715e>// 4 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><a href=https://goplay.tools/snippet/6kzzmHddQgc>testMe</a></p><ul><li>24 byte</li></ul><hr><h3 id=chan>chan
<a class=anchor href=#chan>#</a></h3><blockquote><p>&lsquo;&lsquo;里面的是chan的状态(eg: 一个零值nil通道;一个非零值但已关闭的通道)</p><blockquote><p>&lsquo;空&rsquo;读写阻塞-关闭恐慌;
&lsquo;关闭&rsquo;读为0-关闭写恐慌. 如果是有缓存的chan已关闭，且现在缓存不为空,读正常得到数据
<a href=/go-goroutine/#refer-anchor1><sup>1</sup></a></p></blockquote></blockquote><hr><ul><li><p>what: 从外部看进来.</p><ul><li>不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存(<strong>即通信顺序进程（Communicating sequential processes，CSP）</strong>)</li></ul><pre tabindex=0><code>|thread A|--------[memory]--------|thread B|
|goroutine A|-----[channel]-------|goroutine B|
</code></pre><ul><li>先进先出<code>（FIFO：first in first out）</code>数据队列<ul><li>可以把一个通道看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此通道发送数据，另外一些协程可以从此通道接收数据。</li></ul></li><li>有锁管道<ul><li>Channel是一个用于同步和通信的有锁队列，使用互斥锁解决程序中可能存在的线程竞争问题是很常见的，我们能很容易地实现有锁队列。</li><li>CAS实现的无锁Channel没有提供先进先出的特性，所以该提案暂时也被搁浅了.</li></ul></li></ul></li><li><p>why: 内部结构细节.</p><ul><li>结构
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210410202252.png alt=20210410202252></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>qcount</span>   <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// - 数组长度，即已有元素个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>dataqsiz</span> <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// - 数组容量，即可容纳元素个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>buf</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// - 数组地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>elemsize</span> <span style=color:#66d9ef>uint16</span>         <span style=color:#75715e>// - 元素大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>closed</span>   <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>elemtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span> <span style=color:#75715e>// 元素类型 golang运行时中，内存复制、垃圾回收等机制依赖数据的类型信息，所以hchan中还要有一个指针，指向元素类型的类型元数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sendx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// - 下一次写下标位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>recvx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// - 下一次读下标位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>recvq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// 读等待队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sendq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// 写等待队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lock</span>     <span style=color:#a6e22e>mutex</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>waitq</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>first</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>last</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>前面有<code>-</code>的就是无缓冲chan不需要的字段。
<a href=https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L345>sudog</a></p></blockquote></li><li><p>how: chan的实践，一般用它来干什么？</p><ul><li>五种操作：<ul><li><code>close(ch)</code></li><li><code>ch &lt;- v</code></li><li><code>&lt;-ch</code><ul><li><code>v = &lt;-ch</code></li><li><code>v, sentBeforeClosed = &lt;-ch</code></li></ul></li><li><code>cap(ch)</code></li><li><code>len(ch)</code></li></ul></li></ul></li></ul><p><a href=https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fnref:12>https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fnref:12</a></p><p><a href="https://docs.google.com/presentation/d/1EUOK5qZBdzKTUGbI3iMhHnhwI60pVsg8ISm3jB1D_K8/edit#slide=id.g138e72fb17_0_0">https://docs.google.com/presentation/d/1EUOK5qZBdzKTUGbI3iMhHnhwI60pVsg8ISm3jB1D_K8/edit#slide=id.g138e72fb17_0_0</a></p><p><a href=https://golang.design/under-the-hood/zh-cn/part1basic/ch03lang/chan/#select->https://golang.design/under-the-hood/zh-cn/part1basic/ch03lang/chan/#select-</a>
<a href="https://docs.google.com/presentation/d/18_9LcMc8u93aITZ6DqeUfRvOcHQYj2gwxhskf0XPX2U/edit#slide=id.g5ea99f63e9_0_26">https://docs.google.com/presentation/d/18_9LcMc8u93aITZ6DqeUfRvOcHQYj2gwxhskf0XPX2U/edit#slide=id.g5ea99f63e9_0_26</a></p><hr><h3 id=errorunwrap>error.Unwrap
<a class=anchor href=#errorunwrap>#</a></h3><ul><li><ol><li>通过消除错误来消除错误处理</li></ol></li><li><ol start=2><li><a href=https://blog.golang.org/errors-are-values>Errors are values</a></li></ol><ul><li>错误只处理一次</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>errWriter</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>   <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Writer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ew</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>errWriter</span>) <span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ew</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ew</span>.<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>ew</span>.<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>buf</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ew</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>errWriter</span>{<span style=color:#a6e22e>w</span>: <span style=color:#a6e22e>fd</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>ew</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>p0</span>[<span style=color:#a6e22e>a</span>:<span style=color:#a6e22e>b</span>])
</span></span><span style=display:flex><span><span style=color:#a6e22e>ew</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>p1</span>[<span style=color:#a6e22e>c</span>:<span style=color:#a6e22e>d</span>])
</span></span><span style=display:flex><span><span style=color:#a6e22e>ew</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>p2</span>[<span style=color:#a6e22e>e</span>:<span style=color:#a6e22e>f</span>])
</span></span><span style=display:flex><span><span style=color:#75715e>// and so on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ew</span>.<span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ew</span>.<span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><ul><li>将错误视为不透明的值对于生成松散耦合的软件很重要，所以如果对错误值所做的唯一事情是如下两个方面的话，则原始错误是什么类型就无关紧要了。</li></ul><blockquote><ul><li>检查是否为 nil</li><li>打印或记录日志</li></ul></blockquote><ul><li>但是，在某些场景，您确实需要恢复原始错误, 然后再判断的场景吗。</li></ul></blockquote><ul><li><ol start=3><li>向错误添加上下文</li></ol><ul><li><code>fmt.Errorf</code></li></ul></li><li><p>防止原始的错误类型被掩盖</p><ul><li><code>error.Unwrap</code></li></ul></li></ul><pre tabindex=0><code>错误发生一般是从外部，比如数据库，缓存，其他调用第三方导致的。

[一般有error code] ---来源---&gt; [转换成中间值] ---去向---&gt; [最后变成输出给外面的error code AND error message]
</code></pre><blockquote><p>其中<strong>中间值</strong>是在自己系统中统一的，只要<strong>来源</strong>到这个系统的，都要先把错误码转为系统的中间值.</p></blockquote><script src=https://gist.github.com/zput/e8a55751fabb0e8ba9595f70a834f10c.js></script><hr><h2 id=跟类型相关>跟类型相关
<a class=anchor href=#%e8%b7%9f%e7%b1%bb%e5%9e%8b%e7%9b%b8%e5%85%b3>#</a></h2><ul><li>what:都需要思考在内存中怎么表示的?</li></ul><h3 id=类型系统>类型系统
<a class=anchor href=#%e7%b1%bb%e5%9e%8b%e7%b3%bb%e7%bb%9f>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mType</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>mType</span>) <span style=color:#a6e22e>Method</span>(){
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mObject</span> <span style=color:#a6e22e>mType</span>
</span></span></code></pre></div><ul><li>我们知道mObject内存布局代表的是一块内存,有8个字节，那么mObject怎么调用<code>mObject.Method()</code>?<ul><li><code>mObject.Method()</code> &mdash;> <code>Method(mObject)</code>调用方法，就是调用函数，对象自己当作第一个参数,但是这仅仅是在编译阶段，编译器可以进行转换，</li><li>但是为了支持在运行阶段的语言特性，比如反射，接口动态派发、类型断言,所以编译器会给每种类型生成对应的类型描述信息写入可执行文件，这些类型描述信息就是<strong>类型元数据</strong>,方便在运行时操作.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>myslice</span> []<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ms</span> <span style=color:#a6e22e>myslice</span>) <span style=color:#a6e22e>Len</span>(){
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(len(<span style=color:#a6e22e>ms</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ms</span> <span style=color:#a6e22e>myslice</span>) <span style=color:#a6e22e>Cap</span>(){
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(cap(<span style=color:#a6e22e>ms</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118195910.png alt=20210118195910></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>slicetype</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typ</span>  <span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://github.com/golang/go/blob/642329fdd55aabafc67b3a7c50902e29125621ab/src/runtime/type.go#L416>type slicetype struct</a></p><ul><li>其中<code>_type</code>
<a href=https://github.com/golang/go/blob/642329fdd55aabafc67b3a7c50902e29125621ab/src/runtime/type.go#L31>type _type struct</a></li><li>其中<code>uncommontype</code>
<a href=https://github.com/golang/go/blob/642329fdd55aabafc67b3a7c50902e29125621ab/src/runtime/type.go#L353>type uncommontype struct</a></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118183705.png alt=类型总结></p><p>rune与int32就是别名关系.
// TODO
如何比较它们是否相等?</p><h3 id=跟函数定义的结构相关>跟函数定义的结构相关
<a class=anchor href=#%e8%b7%9f%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89%e7%9a%84%e7%bb%93%e6%9e%84%e7%9b%b8%e5%85%b3>#</a></h3><ul><li><code>Function Value</code>本质上是一个指针，却不直接指向函数指令入口，而是指向<code>runtime.funcval结构体</code>,然后再由这个结构体来指向函数指令入口。<ul><li>为了闭包.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>funcval</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118201453.png alt=20210118201453></p><p><a href=https://mp.weixin.qq.com/s/iFYkcLbNK5pOA37N7ToJ5Q>【Golang】图解Function value</a></p><h4 id=函数调用栈细节>函数调用栈细节
<a class=anchor href=#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e6%a0%88%e7%bb%86%e8%8a%82>#</a></h4><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118203758.png alt=20210118203758></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118203013.png alt=20210118203013></p><ul><li>为什么被调用函数, 改变不了caller的传给callee的参数?</li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118203111.png alt=20210118203111></p><ul><li>如果一个函数调用几个函数,且他们的形参个数不一, 大小不一, 那么这个caller的栈大小,是:
自己的参数+最大(参数字节和)的callee的值.
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118203215.png alt=20210118203215></li></ul><h4 id=闭包>闭包
<a class=anchor href=#%e9%97%ad%e5%8c%85>#</a></h4><ul><li>what:在内存中怎么表示的<ul><li>闭包有自由变量(函数外定义,函数内被引用).</li><li>go语言里面返回一个闭包函数其实就是:<strong>一个funcval结构体加上捕获的变量</strong>.<ul><li>只是如果这个变量在赋给初值以后没有再改变,与后面又被改变两种情况.</li></ul></li></ul></li><li>why:</li><li>how:<ul><li>通过有捕获列表的Function Value实现.</li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118202701.png alt=20210118202701></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118202810.png alt=20210118202810></p><h4 id=方法method>方法(method)
<a class=anchor href=#%e6%96%b9%e6%b3%95method>#</a></h4><p>// TODO</p><h4 id=defer三阶段>defer三阶段
<a class=anchor href=#defer%e4%b8%89%e9%98%b6%e6%ae%b5>#</a></h4><ul><li>what:<ul><li>defer在内存中怎么表示的?<ul><li>调用<code>defer B(a)</code>[a是int64]&mdash;><code>func deferproc(size int32, fn *funcval)</code>&mdash;><code>deferproc(8, B's funcval Addr)</code>,就变成了调用deferproc函数.
<a href=https://github.com/golang/go/blob/a5a5e2c968eb14335f4e46606d8edfbdbdcea728/src/runtime/panic.go#L223>func deferproc(siz int32, fn *funcval)</a></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131115103.png alt=20210131115103></li></ul></li></ul></li><li>why:</li><li>how:<ul><li><a href="https://haicoder.net/note/golang/golang-defer-usage.html#:~:text=Go%20%E8%AF%AD%E8%A8%80%20%E4%B8%AD%E7%9A%84%20defer%20%E8%AF%AD%E5%8F%A5%E7%94%A8%E4%BA%8E%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%8C%E6%AF%8F%E6%AC%A1,defer%20%E9%83%BD%E4%BC%9A%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%8E%8B%E5%85%A5%E6%A0%88%E4%B8%AD%EF%BC%8C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%89%8D%E5%86%8D%E6%8A%8A%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%96%E5%87%BA%E5%B9%B6%E6%89%A7%E8%A1%8C%E3%80%82%20Golang%20%E4%B8%AD%E7%9A%84%20defer%20%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E5%A4%84%E7%90%86%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE%E3%80%81%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E7%AD%89%E3%80%82">关键字return不是一个原子操作，实际上return只代理汇编指令 ret，即将跳转程序执行。比如语句return i，实际上分两步进行，即将i值存入栈中作为返回值，然后执行跳转</a></li></ul></li></ul><blockquote><p>只要懂得<code>defer</code>函数其实会被编译器编译成<code>deferproc function</code>。</p></blockquote><h5 id=before-113>before 1.13
<a class=anchor href=#before-113>#</a></h5><blockquote><p>deferproc函数填充一个
<a href=https://github.com/golang/go/blob/6b37b15d9520f9fa2b819e66a37fac4b2d08da78/src/runtime/runtime2.go#L907>_defer结构体</a>,参数注册时候会拷贝到堆上,执行时候又拷贝到栈上.</p><blockquote><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131115535.png alt=20210131115535>
<a href=https://github.com/golang/go/blob/a5a5e2c968eb14335f4e46606d8edfbdbdcea728/src/runtime/panic.go#L244>生成的_defer struct放到g._defer链表,且每次都放链表头,这样串联起来.</a></p><blockquote><p><a href=https://github.com/golang/go/blob/a5a5e2c968eb14335f4e46606d8edfbdbdcea728/src/runtime/runtime2.go#L417>g._defer</a></p></blockquote></blockquote></blockquote><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118204052.png alt=deferproc函数会返回0></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118204243.png alt=20210118204243></p><h6 id=测试题>测试题
<a class=anchor href=#%e6%b5%8b%e8%af%95%e9%a2%98>#</a></h6><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118204350.png alt=小测试></li></ul><h5 id=113>1.13
<a class=anchor href=#113>#</a></h5><ul><li>1.13如何解决慢的问题?<ul><li><p>why:为什么慢?</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131120919.png alt="before 1.13问题"></li></ul></li><li><p>how:</p><ul><li>不让_defer结构体参数在栈和堆之间进行拷贝,直接在栈上定义_defer结构体,和参数.<ul><li><a href=https://github.com/golang/go/blob/a5a5e2c968eb14335f4e46606d8edfbdbdcea728/src/runtime/panic.go#L276>func deferprocStack(d *_defer)</a></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118205046.png alt=20210118205046></li></ul></li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkDefer</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:=</span><span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span>&lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Defer</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Defer</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>)(<span style=color:#a6e22e>r</span> <span style=color:#66d9ef>int</span>){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>(){
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>r</span><span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>r</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>*</span><span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=114>1.14
<a class=anchor href=#114>#</a></h5><ul><li>1.14如何解决慢的问题?<ul><li>why:为什么慢?<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131120919.png alt="before 1.13问题"></li></ul></li><li>how:<ul><li>直接省去上面两个步骤: 省去构造_defer链表项,并注册到g._defer链表的过程.<ul><li>把defer后面函数需要的参数定义为局部变量,然后在函数返回前直接调用defer后面的函数.</li><li>如果需要到执行阶段才能确定是否需要被调用执行, go使用标识变量df来解决这个问题.<code>var df byte</code>df中的每一位标识一个defer函数是否需要被执行 .</li></ul></li></ul></li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118205208.png alt=20210118205208></p><ul><li>思考为什么不支持循环defer?</li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118205340.png alt=20210118205340></p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118205418.png alt=20210118205418></p><h4 id=panic-and-recover>panic AND recover
<a class=anchor href=#panic-and-recover>#</a></h4><p>first: panic执行defer函数的方式:先标记后释放,为了终止之前发生的panic.
second: 异常信息的输出方式:所有还在panic链表上的项都会被输出.</p><ul><li>what:<ul><li><code>panic()</code>函数执行的时候也是填充一个
<a href=https://github.com/golang/go/blob/6b37b15d9520f9fa2b819e66a37fac4b2d08da78/src/runtime/runtime2.go#L942>type _panic struct</a>结构体,放入<code>goroutine's _panic</code>链表中,然后不再执行panic后面的代码,返回,就开始检查<code>goroutine's _defer</code>链表,如果发现_defer&rsquo;s SP是这个panic所在函数的,就先置started为true,_panic指针指向导致这个defer运行的panic(<strong>这是为了当defer里面又有其他panic</strong>).当defer执行完后再执行g._panic从链表尾开始输出.<ul><li>填充一个_panic结构体</li><li>不执行panic函数后面的代码, 执行_defer链表。</li></ul></li></ul></li><li>why:</li><li>how:<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131142819.png alt=20210131142819></li><li>panic&mdash;>defer&ndash;>panic<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131144806.png alt=defer内部再次panic></li></ul></li></ul></li></ul><p>recover
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131154620.png alt=20210131154620></p><ul><li>what:<ul><li>recover只把当前的_panic.recoved设置为true.<ul><li>然后panic流程会在每个defer执行完毕后,检查次panic是否已经恢复,如果恢复就把它从g._panic链表中移除.<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131152805.png alt=20210131152805></li></ul></li></ul></li></ul></li><li>why:</li><li>how:<ul><li>当_panic被移除后,我们需要跳出panic流程,我们就恢复到defer执行流程(利用它里面的SP, PC),最后ret==1,跳转到
<a href=https://github.com/golang/go/blob/a5a5e2c968eb14335f4e46606d8edfbdbdcea728/src/runtime/panic.go#L524>func deferreturn(arg0 uintptr)</a><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131154527.png alt=20210131154527></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferreturn</span>(<span style=color:#a6e22e>arg0</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallersp</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sp</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>sp</span> { <span style=color:#75715e>// 如果g._defer链表中头的SP不相等(说明不是这个函数定义的defer)就跳出,不再继续执行.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><ul><li>补充一下，上面可能很难理解，看下图，它有两个<code>runtime.deferreturn()</code>,如果函数是正常结束，那么会执行第一个<code>runtime.deferreturn()</code>。如果因为中间panic,<ul><li>填充一个_panic结构体;</li><li>不执行panic函数后面的代码, 执行_defer链表。</li><li>当_defer链表中某一个_defer有recover函数<ul><li>recover只把当前的_panic.recoved设置为true.<ul><li>然后panic流程会在每个defer执行完毕后,检查次panic是否已经恢复,如果恢复就把它从g._panic链表中移除.</li></ul></li></ul></li><li>此时，panic被移除了，&mdash;> 需要跳出这个panic流程</li><li>恢复_defer链表中的sp,它就到了下图中的<code>注册~~~~~></code>这个地方。<ul><li>返回1，所以跳到第二个<code>runtime.deferreturn()</code>.
<img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118204052.png alt=deferproc函数会返回0>
// TODO 如何恢复？</li></ul></li></ul></li></ul></li></ul></li></ul><p><a href=https://goplay.tools/snippet/qoxyANNV481>https://goplay.tools/snippet/qoxyANNV481</a></p><h5 id=测验>测验
<a class=anchor href=#%e6%b5%8b%e9%aa%8c>#</a></h5><p>它的输出结果是什么?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferA</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;deferA&#34;</span>)
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;panicA&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>deferA</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello World&#34;</span>)
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;main&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://goplay.tools/snippet/G5zFPvuiEdJ>https://goplay.tools/snippet/G5zFPvuiEdJ</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>A</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>A1</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>A2</span>()
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;panicA&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>A1</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;A1&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>A2</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>B1</span>()
</span></span><span style=display:flex><span>	panic(<span style=color:#e6db74>&#34;panicA2&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>B1</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> recover()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;B1---&gt;&#34;</span>, <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>A</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://goplay.tools/snippet/phXUi8KDi61>https://goplay.tools/snippet/phXUi8KDi61</a></p><h3 id=跟interface相关>跟interface相关
<a class=anchor href=#%e8%b7%9finterface%e7%9b%b8%e5%85%b3>#</a></h3><h4 id=接口>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3>#</a></h4><pre tabindex=0><code>eface
iface
	interfacetype
</code></pre><h5 id=eface>eface
<a class=anchor href=#eface>#</a></h5><blockquote><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210118205914.png alt=20210118205914></p><blockquote><p>其中<code>_type</code>
<a href=https://github.com/golang/go/blob/642329fdd55aabafc67b3a7c50902e29125621ab/src/runtime/type.go#L31>type _type struct</a></p></blockquote></blockquote><h5 id=iface>iface
<a class=anchor href=#iface>#</a></h5><blockquote><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210119141924.png alt=20210119141924></p><blockquote><p><a href=https://github.com/golang/go/blob/642329fdd55aabafc67b3a7c50902e29125621ab/src/runtime/type.go#L366>type interfacetype struct {</a></p></blockquote></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>interfacetype</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typ</span>     <span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pkgpath</span> <span style=color:#a6e22e>name</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mhdr</span>    []<span style=color:#a6e22e>imethod</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>如果接口类型与动态类型确定了,那么itab的就固定了,此时它是可以复用的.<ul><li>go会把itab缓存起来.</li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210119142057.png alt=20210119142057></p><h4 id=类型断言>类型断言
<a class=anchor href=#%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80>#</a></h4><h4 id=reflect>reflect
<a class=anchor href=#reflect>#</a></h4><h5 id=reflecttype>reflect.Type
<a class=anchor href=#reflecttype>#</a></h5><ul><li>what:<ul><li><a href=https://github.com/golang/go/blob/9ec21a8f347e760945ca0f58ad72062588f08577/src/reflect/type.go#L1368>TypeOf</a></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// TypeOf returns the reflection Type that represents the dynamic type of i.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If i is a nil interface value, TypeOf returns nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Type</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>eface</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyInterface</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>toType</span>(<span style=color:#a6e22e>eface</span>.<span style=color:#a6e22e>typ</span>)
</span></span><span style=display:flex><span>}}
</span></span></code></pre></div><ul><li>why:</li><li>how:<ul><li>TypeOf它的<strong>输入参数是eface</strong>,<strong>返回参数是iface类型</strong>(因为
<a href=https://github.com/golang/go/blob/9ec21a8f347e760945ca0f58ad72062588f08577/src/reflect/type.go#L38>type Type interface</a>是一个非空接口类型.)<ul><li>所以需要转换一下,下图有说明.</li></ul></li></ul></li></ul><blockquote><p>confliction:</p><blockquote><p>空接口类型的参数只能接收地址的需求.</p><blockquote><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210131171655.png alt=20210131171655>
TOOD:感觉这个地方与reflect不能Set成员函数也有关系.</p></blockquote></blockquote></blockquote><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210119152902.png alt=20210119152902></p><ul><li>因为reflect.Type也是一个非空接口类型, 它有许多方法.所以使用上节所用的非空接口类型。</li></ul><h5 id=reflectvalue>reflect.Value
<a class=anchor href=#reflectvalue>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Value</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// typ holds the type of the value represented by a Value.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ptr</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The lowest bits are flag bits:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	- flagStickyRO: obtained via unexported not embedded field, so read-only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	- flagEmbedRO: obtained via unexported embedded field, so read-only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	- flagIndir: val holds a pointer to the data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	- flagAddr: v.CanAddr is true (implies flagIndir)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//	- flagMethod: v is a method value.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>flag</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://github.com/golang/go/blob/f0ff6d4a67ec9a956aa655d487543da034cf576b/src/reflect/value.go#L49>flagIndir的解释</a></p><p>注意点：<code>rtype</code>这个结构体与 <code>../runtime/type.go:/^type._type</code>是要保持一致的(一一对应)。</p><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210119152952.png alt=20210119152952></p><p>继续来看下这个<code>unpackEface</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// unpackEface converts the empty interface i to a Value.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>unpackEface</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>emptyInterface</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>	<span style=color:#75715e>// NOTE: don&#39;t read e.word until we know whether it is really a pointer or not.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>typ</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 下面的这些主要是构建一个Value结构体中的一个字段flag
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flag</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Kind</span>())<span style=color:#75715e>// 这里t.Kind()就是rtype或者说_type中的kind字段
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ifaceIndir</span>(<span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>f</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>flagIndir</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>word</span>, <span style=color:#a6e22e>f</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>rtype</span>) <span style=color:#a6e22e>Kind</span>() <span style=color:#a6e22e>Kind</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Kind</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>kind</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>kindMask</span>) }
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>kindMask</span>        = (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//取最后的五个bits。
</span></span></span><span style=display:flex><span><span style=color:#75715e>//最终再强制转为flag类型---》 rtype使用Kind方法可以得到实际的Kind值
</span></span></span><span style=display:flex><span><span style=color:#75715e>//我们看下flag得到Kind值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#a6e22e>flag</span>) <span style=color:#a6e22e>kind</span>() <span style=color:#a6e22e>Kind</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Kind</span>(<span style=color:#a6e22e>f</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>flagKindMask</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> 	<span style=color:#a6e22e>flagKindMask</span>    <span style=color:#a6e22e>flag</span> = <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#a6e22e>flagKindWidth</span> <span style=color:#f92672>-</span> 
</span></span><span style=display:flex><span><span style=color:#75715e>//是一模一样的。
</span></span></span></code></pre></div><p><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20210119185041.png alt=20210119185041></p><pre tabindex=0><code>// --------------------------
// --------------------------
// --------------------------
</code></pre><h2 id=运行时>运行时:
<a class=anchor href=#%e8%bf%90%e8%a1%8c%e6%97%b6>#</a></h2><h3 id=并发编程>并发编程
<a class=anchor href=#%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b>#</a></h3><h4 id=同步原语>同步原语
<a class=anchor href=#%e5%90%8c%e6%ad%a5%e5%8e%9f%e8%af%ad>#</a></h4><ul><li>what:<ul><li>并发同步是指如何控制若干并发计算（在Go中，即协程），从而<ul><li>避免在它们之间产生数据竞争的现象；</li><li>避免在它们无所事事的时候消耗CPU资源。</li></ul></li><li>并发同步有时候也称为数据同步。</li></ul></li><li>why:<ul><li>避免在它们之间产生数据竞争的现象；</li><li>避免在它们无所事事的时候消耗CPU资源。</li></ul></li><li>how:<ul><li><p>通道用例大全</p></li><li><p>如何优雅地关闭通道</p></li><li><p><a href=https://gfw.go101.org/article/concurrent-synchronization-more.html>sync标准库包中提供的并发同步技术</a></p><ul><li>sync.WaitGroup（等待组）类型: ：Add(delta int)、Done()和Wait()</li><li>sync.Once类型: Do(f func())方法<ul><li>一个sync.Once值被用来确保一段代码在一个并发程序中被执行且仅被执行一次</li></ul></li><li>sync.Mutex（互斥锁）和sync.RWMutex（读写锁）类型: 实现了<code>sync.Locker</code>接口类型。 所以这两个类型都有两个方法：Lock()和Unlock()，<ul><li>用来保护一份数据不会被多个使用者同时读取和修改。</li><li>*sync.RWMutex类型还有两个另外的方法：RLock()和RUnlock()，<ul><li>用来支持多个读取者并发读取一份数据但防止此份数据被某个数据写入者和其它数据访问者（包括读取者和写入者）同时使用</li></ul></li></ul></li><li>sync.Cond类型:提供了一种有效的方式来实现多个协程间的<strong>通知</strong>。<ul><li>成员： sync.Locker类型的名为L的字段</li><li>成员函数： Wait()、Signal()和Broadcast()。<ul><li>每个Cond值维护着一个先进先出等待协程队列。 对于一个可寻址的Cond值c，<ul><li>c.Wait()必须在c.L字段值的锁被成功获取的时候调用；否则，c.Wait()调用将造成一个恐慌。 一个c.Wait()调用将<ul><li><ol><li>首先将当前协程入到c所维护的等待协程队列；</li></ol></li><li><ol start=2><li>然后调用c.L.Unlock()释放c.L的锁；</li></ol></li><li><ol start=3><li>然后使当前协程进入阻塞状态；（当前协程将被另一个协程通过c.Signal()或c.Broadcast()调用唤醒而重新进入运行状态。）</li></ol><ul><li>一旦当前协程重新进入运行状态，c.L.Lock()将被调用以试图重新获取c.L字段值的锁。 此c.Wait()调用将在此试图成功之后退出。</li></ul></li></ul></li><li>一个c.Signal()调用将唤醒并移除c所维护的等待协程队列中的第一个协程（如果此队列不为空的话）。</li><li>一个c.Broadcast()调用将唤醒并移除c所维护的等待协程队列中的所有协程（如果此队列不为空的话）。</li></ul></li></ul></li></ul></li></ul></li><li><p><a href=https://gfw.go101.org/article/concurrent-atomic-operation.html>sync/atomic标准库包中提供的原子操作技术</a></p><ul><li><code>T</code>&mdash;可以换成&mdash;>内置<code>int32、int64、uint32、uint64和uintptr</code>类型<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AddT</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>delta</span> <span style=color:#a6e22e>T</span>)(<span style=color:#a6e22e>new</span> <span style=color:#a6e22e>T</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadT</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>) (<span style=color:#a6e22e>val</span> <span style=color:#a6e22e>T</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>StoreT</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>val</span> <span style=color:#a6e22e>T</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>SwapT</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>T</span>) (<span style=color:#a6e22e>old</span> <span style=color:#a6e22e>T</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CompareAndSwapT</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>T</span>) (<span style=color:#a6e22e>swapped</span> <span style=color:#66d9ef>bool</span>)
</span></span></code></pre></div></li></ul></li><li><p>我们也可以利用网络和文件读写来做并发同步，但是这样的并发同步方法使用在一个程序进程内部时效率相对比较低。 一般来说，这样的方法多适用于多个进程之间或多个主机之间的并发同步。《Go语言101》中不介绍这样的并发同步方法。</p></li></ul></li></ul><h5 id=内存顺序保证>内存顺序保证
<a class=anchor href=#%e5%86%85%e5%ad%98%e9%a1%ba%e5%ba%8f%e4%bf%9d%e8%af%81>#</a></h5><ul><li>Go中的内存顺序保证<ul><li>内存顺序<ul><li>what: 调整指令执行顺序，从而使得指令执行顺序和代码中指定的顺序不太一致。 指令顺序也称为内存顺序。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201217193316.png alt=20201217193316></li></ul></li><li>why:</li><li>how:<ul><li>通道操作相关的顺序保证:<ul><li><ol><li>一个通道上的第n次成功发送操作的开始发生在此通道上的第n次成功接收操作完成之前，无论此通道是缓冲的还是非缓冲的。</li></ol><ul><li><strong>如果是缓冲，一边是发送，数据进入到通道中，当另一边接收的时候，肯定在前一边之后。</strong></li></ul></li><li><ol start=2><li><strong>一个容量为m通道上的第n次成功接收操作的开始发生在此通道上的第n+m次发送操作完成之前</strong>。 特别地，如果此通道是非缓冲的（m == 0），则此通道上的第n次成功接收操作的开始发生在此通道上的第n次发送操作完成之前。</li></ol></li><li><ol start=3><li>一个通道的关闭操作发生在任何因为此通道被关闭而从此通道接收到了零值的操作完成之前。</li></ol></li></ul></li><li>事实上， 对一个非缓冲通道来说，其上的第n次成功发送的完成和其上的第n次成功接收的完成应被视为同一事件。<ul><li>好像他们就是保证当阻塞发送接收的时候，<strong>他们可以当成一个事件，同时发生的。</strong></li></ul></li><li>example:<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201217195138.png alt=20201217195138></li></ul></li></ul></li></ul></li></ul></li></ul><h5 id=sync包>sync包
<a class=anchor href=#sync%e5%8c%85>#</a></h5><p><a href=goroutine/sync_map.go>sync.Map</a></p><ol><li>sync.Map的核心实现 - 两个map，一个用于写，另一个用于读，这样的设计思想可以类比<code>缓存与数据库</code></li><li>sync.Map的局限性 - 如果写远高于读，dirty->readOnly 这个类似于 <code>刷数据</code> 的频率就比较高，不如直接用 <code>mutex + map</code> 的组合</li><li>sync.Map的设计思想 - 保证高频读的无锁结构、空间换时间</li></ol><p><a href=goroutine/sync_cond.go>sync.Cond</a></p><ol><li>sync.Cond的核心实现 - 通过一个锁，封装了<code>notify 通知</code>的实现，包括了<code>单个通知</code>与<code>广播</code>这两种方式</li><li>sync.Cond与channel的异同 - channel应用于<code>一收一发</code>的场景，sync.Cond应用于<code>多收一发</code>的场景</li><li>sync.Cond的使用探索 - 多从专业社区收集意见
<a href=https://github.com/golang/go/issues/21165>https://github.com/golang/go/issues/21165</a></li></ol><p><a href=goroutine/sync_pool.go>sync.Pool</a></p><ol><li>sync.Pool的核心作用 - 读源码，<code>缓存稍后会频繁使用的对象</code>+<code>减轻GC压力</code></li><li>sync.Pool的Put与Get - Put的顺序为<code>local private-> local shared</code>，Get的顺序为 <code>local private -> local shared -> remote shared</code></li><li>思考sync.Pool应用的核心场景 - <code>高频使用且生命周期短的对象，且初始化始终一致</code>，如fmt</li><li>探索Go1.13引入<code>victim</code>的作用 - 了解<code>victim cache</code>的机制</li></ol><h4 id=context上下文>context(上下文)
<a class=anchor href=#context%e4%b8%8a%e4%b8%8b%e6%96%87>#</a></h4><p><a href=/go-goroutine/#refer-anchor2><sup>1</sup></a>
// TODO</p><ul><li>四个方法</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Context</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Deadline</span>() (<span style=color:#a6e22e>deadline</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>, <span style=color:#a6e22e>ok</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Done</span>() <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}  <span style=color:#75715e>//返回一个channel.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Err</span>() <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Value</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>interface</span>{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>内部Ctx<ul><li>cancelCtx<ul><li>WithCancel: <strong>把父Context装进子Context&rsquo;s Context.</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>parent</span> <span style=color:#a6e22e>Context</span>) (<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#a6e22e>CancelFunc</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>parent</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;cannot create context from nil parent&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newCancelCtx</span>(<span style=color:#a6e22e>parent</span>) <span style=color:#75715e>// 常见一个新的子context；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>propagateCancel</span>(<span style=color:#a6e22e>parent</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>) <span style=color:#75715e>// 然后准备把新生成的子context加入到parent中；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>Canceled</span>) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>目前 context 有个非常重要点, 在 Go 只有阻塞式调用没有非阻塞调用，所以必须要有 context cancel (or Done() or Err()) 相关操作，否则操作一旦陷进去没响应 (本质是 goroutines 调度控制)，goroutine 就无法继续了.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>()  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ctx</span>,<span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithCancel</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>())
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>Speak</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cancel</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Speak</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>)  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Tick</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;我要闭嘴了&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;balabalabalabala&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><a href=https://gist.github.com/zput/27591a68b2384b63e14c92546394b6e7>https://gist.github.com/zput/27591a68b2384b63e14c92546394b6e7</a></li><li><a href=https://gist.github.com/zput/d798e8e43498944e3e77111198cdefde>https://gist.github.com/zput/d798e8e43498944e3e77111198cdefde</a></li></ul></li><li>valueCtx<ul><li>WithValue:</li></ul></li><li>emptyCtx</li></ul></li><li><script src=https://gist.github.com/zput/0f89a600018cc5b6095f1b4ae77aca8e.js></script></li></ul><p><a href=https://play.golang.org/p/tifKA0ruOR8>这里需要说明的是type interface可以放进struct里面：</a></p><h3 id=内存管理>内存管理
<a class=anchor href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86>#</a></h3><h4 id=gc>GC
<a class=anchor href=#gc>#</a></h4><h4 id=逃逸分析>逃逸分析
<a class=anchor href=#%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90>#</a></h4><ul><li><p>what:</p><ul><li>指针（或者引用）的逃逸(Escape): 当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用.<ul><li>逃逸分析: 是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。<ul><li>必然发生逃逸:<ul><li>在某个函数中new或字面量创建出的变量，将其指针作为函数返回值，则该变量一定发生逃逸（构造函数返回的指针变量一定逃逸）；</li><li>被已经逃逸的变量引用的指针，一定发生逃逸；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>User</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Username</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Password</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span>      <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;aaa&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>u</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>User</span>{<span style=color:#a6e22e>a</span>, <span style=color:#e6db74>&#34;123&#34;</span>, <span style=color:#ae81ff>12</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Call1</span>(<span style=color:#a6e22e>u</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Call1</span>(<span style=color:#a6e22e>u</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%v&#34;</span>,<span style=color:#a6e22e>u</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
</span></span></span><span style=display:flex><span><span style=color:#75715e> 	p := newPrinter()
</span></span></span><span style=display:flex><span><span style=color:#75715e>	p.doPrintf(format, a)
</span></span></span><span style=display:flex><span><span style=color:#75715e>...
</span></span></span><span style=display:flex><span><span style=color:#75715e>} 
</span></span></span><span style=display:flex><span><span style=color:#75715e>func (p *pp) doPrintf(format string, a []interface{}) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>...
</span></span></span><span style=display:flex><span><span style=color:#75715e>p.printArg(a[argNum], rune(c))
</span></span></span><span style=display:flex><span><span style=color:#75715e>...
</span></span></span><span style=display:flex><span><span style=color:#75715e>} 
</span></span></span><span style=display:flex><span><span style=color:#75715e>func (p *pp) printArg(arg interface{}, verb rune) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>	p.arg = arg
</span></span></span><span style=display:flex><span><span style=color:#75715e>	p.value = reflect.Value{}
</span></span></span><span style=display:flex><span><span style=color:#75715e>...
</span></span></span><span style=display:flex><span><span style=color:#75715e>}
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//-------------上面逃逸，下面没有------------------//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;aaa&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>u</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>User</span>{<span style=color:#a6e22e>a</span>, <span style=color:#e6db74>&#34;123&#34;</span>, <span style=color:#ae81ff>12</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Call1</span>(<span style=color:#a6e22e>u</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Call1</span>(<span style=color:#a6e22e>u</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Call2</span>(<span style=color:#a6e22e>u</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Call2</span>(<span style=color:#a6e22e>u</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Call3</span>(<span style=color:#a6e22e>u</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Call3</span>(<span style=color:#a6e22e>u</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Username</span> = <span style=color:#e6db74>&#34;bbb&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Age</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>go run -gcflags &#34;-m -l&#34; main.go
</span></span></span><span style=display:flex><span><span style=color:#75715e># command-line-arguments
</span></span></span><span style=display:flex><span><span style=color:#75715e>./main.go:23:12: Call3 u does not escape
</span></span></span><span style=display:flex><span><span style=color:#75715e>./main.go:19:12: Call2 u does not escape
</span></span></span><span style=display:flex><span><span style=color:#75715e>./main.go:15:12: Call1 u does not escape
</span></span></span><span style=display:flex><span><span style=color:#75715e>./main.go:11:23: main &amp;User literal does not escape
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><ul><li>被指针类型的slice、map和chan引用的指针，一定发生逃逸；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> make([]<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>,<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>[<span style=color:#e6db74>&#34;aaa&#34;</span>]=<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>,<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span> <span style=color:#f92672>&lt;-</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>f</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>go run -gcflags &#34;-m -l&#34; main.go
</span></span></span><span style=display:flex><span><span style=color:#75715e># command-line-arguments
</span></span></span><span style=display:flex><span><span style=color:#75715e>./main.go:7:2: moved to heap: b
</span></span></span><span style=display:flex><span><span style=color:#75715e>./main.go:11:2: moved to heap: d
</span></span></span><span style=display:flex><span><span style=color:#75715e>./main.go:15:2: moved to heap: f
</span></span></span><span style=display:flex><span><span style=color:#75715e>./main.go:6:11: main make([]*int, 1) does not escape
</span></span></span><span style=display:flex><span><span style=color:#75715e>./main.go:10:11: main make(map[string]*int) does not escape
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div></li><li>必然不会逃逸的情况：<ul><li>指针被未发生逃逸的变量引用；</li><li>仅仅在函数内对变量做取址操作，而未将指针传出；</li></ul></li><li>可能发生逃逸，也可能不会发生逃逸：<ul><li>将指针作为入参传给别的函数；这里还是要看指针在被传入的函数中的处理过程，如果发生了上边的三种情况，则会逃逸；否则不会逃逸；</li></ul></li></ul></li></ul></li></ul></li><li><p>why:</p><ul><li>gc压力<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//我：“golang函数传参是不是应该跟c一样，尽量不要直接传结构体，而要传结构体指针？“
</span></span></span><span style=display:flex><span><span style=color:#75715e>//leader：“不对，咱们项目很多都是直接传结构体的。“
</span></span></span><span style=display:flex><span><span style=color:#75715e>//我：“那样不会造成不必要的内存copy开销吗？”
</span></span></span><span style=display:flex><span><span style=color:#75715e>//leader：“确实会有，但这样可以减小gc压力，因为传值会在栈上分配，而一旦传指针，结构体就会逃逸到堆上。“
</span></span></span></code></pre></div></li><li>不逃逸的对象放栈上，可能逃逸的放堆上:<ul><li>gc的压力: 最大的好处应该是减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。</li><li>因为逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好</li></ul></li><li>同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</li></ul></li><li><p>how:</p><ul><li><code>-gcflags '-m -l'</code></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201217210216.png alt=20201217210216><ul><li>从内部函数开始分析，它的好处的是，如果底部的函数中都没有逃逸，那么最上层的变量就直接放入栈里面就行了，不需要放堆里。<ul><li>这里的objS没有逃逸，而m却逃逸了，这是因为go的逃逸分析不知道objS和m的关系，逃逸分析不知道参数M是<code>struct S</code>的一个成员，所以只能把它分配给堆。</li></ul></li></ul></li></ul></li></ul><p><a href=https://cloud.tencent.com/developer/article/1165660>Golang逃逸分析</a>
<a href=https://www.jianshu.com/p/ad9dbc81a0aa>GoLang-逃逸分析</a></p><p><a href=https://zhuanlan.zhihu.com/p/91559562>https://zhuanlan.zhihu.com/p/91559562</a></p><h4 id=内存泄漏>内存泄漏
<a class=anchor href=#%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f>#</a></h4><ul><li><p>what:</p><ul><li>当使用一门支持自动垃圾回收的语言编程时，一般来说我们不需要关心内存泄露问题，因为程序的运行时会负责回收不再使用的内存。 但是，我们确实也需要知道<strong>一些特殊</strong>的可能会造成暂时性或永久性内存泄露的<strong>情形</strong>。</li></ul></li><li><p>why:</p><ul><li>临时性内存泄露<ul><li>底层共用同一个内存空间引起的：<ul><li>子字符串造成的暂时性内存泄露</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s0</span> []<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>s1</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 假设s1的长度远大于30。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>s0</span> = <span style=color:#a6e22e>s1</span>[len(<span style=color:#a6e22e>s1</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>30</span>:]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>子切片造成的暂时性内存泄露</li><li>因为未重置丢失的切片元素中的指针而造成的临时性内存泄露</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>h</span>() []<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>{new(<span style=color:#66d9ef>int</span>), new(<span style=color:#66d9ef>int</span>), new(<span style=color:#66d9ef>int</span>), new(<span style=color:#66d9ef>int</span>)}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 使用此s切片 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//s[0], s[len(s)-1] = nil, nil // 添加这一行:重置首尾元素指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>3</span>:<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>延迟调用函数导致的临时性内存泄露<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>writeManyFiles</span>(<span style=color:#a6e22e>files</span> []<span style=color:#a6e22e>File</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	 <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>file</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>files</span> {
</span></span><span style=display:flex><span>	 	<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span>	 	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	 		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	 	}
</span></span><span style=display:flex><span>	 	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	 	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>content</span>)
</span></span><span style=display:flex><span>	 	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	 		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	 	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	 	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Sync</span>()
</span></span><span style=display:flex><span>	 	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	 		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	 	}
</span></span><span style=display:flex><span>	 }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	 <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li>永久性内存泄露<ul><li>因为协程被永久阻塞而造成的永久性内存泄露
泄露的场景不仅限于以下两类，但因channel相关的泄露是最多的。<ul><li>channel的读或者写：<ul><li>&lsquo;空&rsquo;读写阻塞-关闭恐慌; &lt;&mdash;> <del>&lsquo;关闭&rsquo;读为0-关闭写恐慌.如果是有缓存的chan已关闭，且现在缓存不为空,读正常得到数.</del></li><li>写：<ul><li>无缓冲channel的阻塞通常是写操作因为没有读而阻塞</li><li>有缓冲的channel因为缓冲区满了，写操作阻塞</li></ul></li><li>读：期待从channel读数据，结果没有goroutine写</li><li>select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。<ul><li><code>default</code></li></ul></li></ul></li></ul></li><li>因为没有停止不再使用的time.Ticker值而造成的永久性内存泄露</li><li>因为不正确地使用终结器（finalizer）而造成的永久性内存泄露</li></ul></li></ul></li><li><p>how: 怎么发现内存泄露,</p><ul><li>在Go中发现内存泄露有2种方法:<ul><li>一个是通用的监控工具;</li><li>另一个是go pprof。</li></ul></li></ul></li></ul><p>当连接在服务器终端上的时候，是没有浏览器可以使用的，Go提供了命令行的方式，能够获取以上5类信息，这种方式用起来更方便。</p><p>使用命令<code>go tool pprof url</code>可以获取指定的profile文件，此命令会发起http请求，然后下载数据到本地，<strong>之后进入交互式模式</strong>(<em>只要进入到交互模式说明已经下载完成，与将要调查的程序无关了</em>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># 下载cpu profile，默认从当前开始收集30s的cpu使用情况，需要等待30s</span>
</span></span><span style=display:flex><span>go tool pprof http://localhost:6060/debug/pprof/profile   <span style=color:#75715e># 30-second CPU profile</span>
</span></span><span style=display:flex><span>go tool pprof http://localhost:6060/debug/pprof/profile?seconds<span style=color:#f92672>=</span><span style=color:#ae81ff>120</span>     <span style=color:#75715e># wait 120s</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 下载heap profile</span>
</span></span><span style=display:flex><span>go tool pprof http://localhost:6060/debug/pprof/heap      <span style=color:#75715e># heap profile</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 下载goroutine profile</span>
</span></span><span style=display:flex><span>go tool pprof http://localhost:6060/debug/pprof/goroutine <span style=color:#75715e># goroutine profile</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 下载block profile</span>
</span></span><span style=display:flex><span>go tool pprof http://localhost:6060/debug/pprof/block     <span style=color:#75715e># goroutine blocking profile</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 下载mutex profile</span>
</span></span><span style=display:flex><span>go tool pprof http://localhost:6060/debug/pprof/mutex
</span></span></code></pre></div><ul><li>top<ul><li>按前面下载的指标是什么，按照它们的大小列出前10个函数，<strong>比如heap是按heap占用多少。</strong></li></ul></li><li>list function_name<ul><li>查看某个函数的代码，以及该函数每行代码的指标信息，如果函数名不明确，会进行模糊匹配，比如list main会列出main.main和runtime.main。</li></ul></li><li>traces<ul><li>打印所有调用栈，以及调用栈的指标信息。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>// 隔一段时间分别运行，抓取它的heap信息.
</span></span><span style=display:flex><span>go tool pprof http://localhost:6060/debug/pprof/heap
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 使用-base Options来以001作为基准，与003来比较。
</span></span><span style=display:flex><span>go tool pprof -base pprof.main.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz pprof.main.alloc_objects.alloc_space.inuse_objects.inuse_space.003.pb.gz
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// top 
</span></span><span style=display:flex><span>top 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// list 上面展示的函数，查看具体代码行。 很像gdb
</span></span><span style=display:flex><span>list xxxxx
</span></span></code></pre></div><p><a href=https://segmentfault.com/a/1190000019222661>https://segmentfault.com/a/1190000019222661</a>
<a href=https://gfw.go101.org/article/memory-leaking.html>https://gfw.go101.org/article/memory-leaking.html</a></p><h2 id=附录>附录
<a class=anchor href=#%e9%99%84%e5%bd%95>#</a></h2><div id=refer-anchor1></div><p>[1]
<a href=https://gfw.go101.org/article/101.html>go101</a></p><div id=refer-anchor2></div><p>[2]
<a href=https://github.com/Junedayday/code_reading>code_reading</a></p><div id=refer-anchor3></div><p>[3]
<a href=https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>Go 语言设计与实现</a></p><hr><hr><hr><h3 id=0方法>0.方法
<a class=anchor href=#0%e6%96%b9%e6%b3%95>#</a></h3><ul><li><p>为指针类型属主隐式声明的<strong>方法</strong></p><ul><li>每个<strong>方法</strong>对应着一个隐式声明的函数</li><li><code>类型T</code>的方法集总是<code>类型*T</code>的方法集的子集。<ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201218212611.png alt=20201218212611></li></ul></li></ul></li><li><p>如何决定一个方法声明使用值类型属主还是指针类型属主？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  <span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Book</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  	<span style=color:#a6e22e>pages</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Books</span> []<span style=color:#a6e22e>Book</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>books</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Books</span>) <span style=color:#a6e22e>Modify</span>() {
</span></span><span style=display:flex><span>  	<span style=color:#f92672>*</span><span style=color:#a6e22e>books</span> = append(<span style=color:#f92672>*</span><span style=color:#a6e22e>books</span>, <span style=color:#a6e22e>Book</span>{<span style=color:#ae81ff>789</span>})
</span></span><span style=display:flex><span>  	(<span style=color:#f92672>*</span><span style=color:#a6e22e>books</span>)[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>pages</span> = <span style=color:#ae81ff>500</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>books</span> = <span style=color:#a6e22e>Books</span>{{<span style=color:#ae81ff>123</span>}, {<span style=color:#ae81ff>456</span>}}
</span></span><span style=display:flex><span>  	<span style=color:#a6e22e>books</span>.<span style=color:#a6e22e>Modify</span>()
</span></span><span style=display:flex><span>  	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>books</span>) <span style=color:#75715e>// [{500} {456} {789}]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span></code></pre></div></li><li><p><code>(&book).SetPages(123)</code>一行为什么可以被简化为<code>book.SetPages(123)</code>呢？</p><ul><li><strong>毕竟，类型Book并不拥有一个SetPages方法。</strong></li><li>这可以看作是Go中为了让代码看上去更简洁而特别设计的语法糖。<ul><li>此语法糖只对可寻址的值类型的属主有效。 编译器会自动将<code>book.SetPages(123)</code>改写为<code>(&book).SetPages(123)</code>。</li><li>但另一方面，我们应该总是认为<code>aBookExpression.SetPages</code>是一个合法的选择器（从语法层面讲），即使表达式<code>aBookExpression</code>被估值为一个不可寻址的Book值（在这种情况下，<code>aBookExpression.SetPages</code>是一个无效但合法的选择器）。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Book</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pages</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#a6e22e>Book</span>) <span style=color:#a6e22e>Pages</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>pages</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Book</span>) <span style=color:#a6e22e>SetPages</span>(<span style=color:#a6e22e>pages</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>pages</span> = <span style=color:#a6e22e>pages</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>book</span> <span style=color:#a6e22e>Book</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%T \n&#34;</span>, <span style=color:#a6e22e>book</span>.<span style=color:#a6e22e>Pages</span>)       <span style=color:#75715e>// func() int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%T \n&#34;</span>, (<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>book</span>).<span style=color:#a6e22e>SetPages</span>) <span style=color:#75715e>// func(int)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// &amp;book值有一个隐式方法Pages。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%T \n&#34;</span>, (<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>book</span>).<span style=color:#a6e22e>Pages</span>)    <span style=color:#75715e>// func() int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 调用这三个方法。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>book</span>).<span style=color:#a6e22e>SetPages</span>(<span style=color:#ae81ff>123</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>book</span>.<span style=color:#a6e22e>SetPages</span>(<span style=color:#ae81ff>123</span>)           <span style=color:#75715e>// 等价于上一行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>book</span>.<span style=color:#a6e22e>Pages</span>())    <span style=color:#75715e>// 123
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>((<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>book</span>).<span style=color:#a6e22e>Pages</span>()) <span style=color:#75715e>// 123
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li></ul></li></ul><p><a href=https://gfw.go101.org/article/method.html>方法</a></p><h3 id=1-new-and-make>1. new And make
<a class=anchor href=#1-new-and-make>#</a></h3><ul><li><p>what: allocates AND initializes</p><ul><li>new<ul><li>(allocates memory).</li></ul></li><li>make<ul><li>(allocates and initializes an object of type slice, map, or chan (only)).</li></ul></li></ul></li><li><p>why:</p></li><li><p>how:</p><ul><li>区别从函数定义就可以看出来:<code>func new(Type) *Type</code> AND <code>func make(t Type, size ...IntegerType) Type</code><ul><li>入参值<ul><li>make 只能用来分配及初始化类型为 slice、map、chan 的数据(slice, map, or chan (only))。new 可以分配任意类型的数据；</li></ul></li><li>输出值<ul><li>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type；</li><li>new 分配的空间被清零。make 分配空间后，会进行<strong>初始化</strong>；</li></ul></li></ul></li></ul></li></ul><p><a href=http://c.biancheng.net/view/5722.html>外部参考</a></p><h4 id=example>example
<a class=anchor href=#example>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>*</span><span style=color:#a6e22e>i</span>=<span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个例子会打印出什么？0还是10?。以上全错，运行的时候会painc，原因如下：</p><pre tabindex=0><code>panic: runtime error: invalid memory address or nil pointer dereference
</code></pre><blockquote><p>从这个提示中可以看出，对于<strong>引用类型的变量，我们不光要声明它</strong>，还要为它<strong>分配内容</strong>空间，否则我们的值放在哪里去呢？这就是上面错误提示的原因。</p></blockquote><p>对于值类型的声明不需要，是因为已经默认帮我们分配好了。</p><p>要分配内存，就引出来今天的new和make。</p><h3 id=2-值类型和引用类型的区别>2. 值类型和引用类型的区别
<a class=anchor href=#2-%e5%80%bc%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h3><ul><li><p>2.1. go语言中没有引用类型。</p><ul><li><a href=https://github.com/golang/go/commit/b34f0551387fcf043d65cd7d96a0214956578f94>the concept &ldquo;reference type&rdquo; has been totally removed from Go spec since Apr 3rd, 2013</a></li></ul></li><li><p>2.2. 引用关系是通过指针和各种内置类型的某些可能的内部结构建立的</p><ul><li><a href=https://gfw.go101.org/article/value-part.html>内部结构的实现定义</a><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 映射类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_map</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hashtableImpl</span> <span style=color:#75715e>// 目前，官方标准编译器是使用哈希表来实现映射的。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 通道类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_channel</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>channelImpl</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 函数类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_function</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>functionImpl</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_slice</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>elements</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 引用着底层的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>len</span>      <span style=color:#66d9ef>int</span>            <span style=color:#75715e>// 当前的元素个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>cap</span>      <span style=color:#66d9ef>int</span>            <span style=color:#75715e>// 切片的容量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_string</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>elements</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span> <span style=color:#75715e>// 引用着底层的byte元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>len</span>      <span style=color:#66d9ef>int</span>   <span style=color:#75715e>// 字符串的长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_interface</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dynamicType</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>         <span style=color:#75715e>// 引用着接口值的动态类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dynamicValue</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 引用着接口值的动态值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_interface</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dynamicTypeInfo</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>dynamicType</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>       <span style=color:#75715e>// 引用着接口值的动态类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>methods</span>     []<span style=color:#f92672>*</span><span style=color:#a6e22e>_function</span> <span style=color:#75715e>// 引用着动态类型的对应方法列表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dynamicValue</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 引用着动态值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li></ul></li><li><p>Question</p><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201216201044.png alt=20201216201044></li><li>但是为什么使用<code>%p</code>来打印的时候这些常规认为的“引用类型”,可以打印，答应我们认为的值类型的时候，出错。<ul><li>从下面的gdb例子中可以看出，我们能打印这些常规认为的“引用类型”,是因为<code>Slice: %p address of 0th element in base 16 notation, with leading 0x</code>, 它实际打印的是第0个元素的地址。而<code>&test</code>是打印的它实际的<code>struct的地址</code>。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>testS</span>(<span style=color:#a6e22e>test</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// test:0xc000078150
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;---test:%p\n&#34;</span>, <span style=color:#a6e22e>test</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// &amp;test:0xc000098028
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;&amp;test:%p\n&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>test</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>s</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;s---:%p\n&#34;</span>, <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;&amp;s[0]---:%p\n&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;&amp;s:%p\n&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>testS</span>(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201216194723.png alt=20201216194723></li></ul></li></ul></li></ul><p><a href=https://golang.org/pkg/fmt/>Package fmt</a>
<a href=https://www.tapirgames.com/blog/golang-has-no-reference-values>There Are No Reference Types in Go</a>
<a href=https://github.com/go101/go101/wiki/About-the-terminology-%22reference-type%22-in-Go>About the terminology &ldquo;reference type&rdquo; in Go</a></p><h3 id=3-计算golang中类型的大小的方式>3. 计算golang中类型的大小的方式
<a class=anchor href=#3-%e8%ae%a1%e7%ae%97golang%e4%b8%ad%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%a4%a7%e5%b0%8f%e7%9a%84%e6%96%b9%e5%bc%8f>#</a></h3><ul><li>struct会不会有填充的（padding）的bit?<ul><li>会的，就像下方的例子中，T.B就是一个bit,但是它后面填充了7个bit.</li></ul></li><li>类似sizeof的函数？<ul><li><code>unsafe.Sizeof()</code></li></ul></li><li>如果是分配在heap中，还可以使用什么方式来评估？<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>ReadMemStats</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m1</span>)<span style=color:#75715e>// 好像一个snapshot,可以评估当前heap的空间.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>T</span>{}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>ReadMemStats</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m2</span>)
</span></span></code></pre></div></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;runtime&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Unlike C, there is no _#pragma pack_ in Go, the real memory allocation
</span></span></span><span style=display:flex><span><span style=color:#75715e>// depends on its implementation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>B</span>  <span style=color:#66d9ef>uint8</span> <span style=color:#75715e>// is a byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>I</span>  <span style=color:#66d9ef>int</span>   <span style=color:#75715e>// it is int32 on my x86 32 bit PC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>P</span>  <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>  <span style=color:#75715e>// it is int32 on my x86 32 bit PC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>S</span>  <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SS</span> []<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// In this case, the `t := T{}` can not measured by this method.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>memUsage</span>(<span style=color:#a6e22e>m1</span>, <span style=color:#a6e22e>m2</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>MemStats</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>(<span style=color:#e6db74>&#34;Alloc:&#34;</span>, <span style=color:#a6e22e>m2</span>.<span style=color:#a6e22e>Alloc</span><span style=color:#f92672>-</span><span style=color:#a6e22e>m1</span>.<span style=color:#a6e22e>Alloc</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;TotalAlloc:&#34;</span>, <span style=color:#a6e22e>m2</span>.<span style=color:#a6e22e>TotalAlloc</span><span style=color:#f92672>-</span><span style=color:#a6e22e>m1</span>.<span style=color:#a6e22e>TotalAlloc</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;HeapAlloc:&#34;</span>, <span style=color:#a6e22e>m2</span>.<span style=color:#a6e22e>HeapAlloc</span><span style=color:#f92672>-</span><span style=color:#a6e22e>m1</span>.<span style=color:#a6e22e>HeapAlloc</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Here is a tricky to get pointer size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>PtrSize</span> = <span style=color:#ae81ff>32</span> <span style=color:#f92672>&lt;&lt;</span> uintptr(^uintptr(<span style=color:#ae81ff>0</span>)<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>63</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>(<span style=color:#e6db74>&#34;PtrSize=&#34;</span>, <span style=color:#a6e22e>PtrSize</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>(<span style=color:#e6db74>&#34;IntSize=&#34;</span>, <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>IntSize</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m1</span>, <span style=color:#a6e22e>m2</span>, <span style=color:#a6e22e>m3</span>, <span style=color:#a6e22e>m4</span>, <span style=color:#a6e22e>m5</span>, <span style=color:#a6e22e>m6</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>MemStats</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>ReadMemStats</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>T</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>ReadMemStats</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m2</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>(<span style=color:#e6db74>&#34;sizeof(uint8)&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>B</span>),
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;offset=&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>B</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>(<span style=color:#e6db74>&#34;sizeof(int)&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>I</span>),
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;offset=&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>I</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>(<span style=color:#e6db74>&#34;sizeof(*int)&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>P</span>),
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;offset=&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>P</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>(<span style=color:#e6db74>&#34;sizeof(string)&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>S</span>),
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;offset=&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>S</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Slice is a structure of Pointer, Len and Cap.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Detail [here](http://blog.golang.org/go-slices-usage-and-internals)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>(<span style=color:#e6db74>&#34;sizeof([]string)&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>SS</span>),
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;offset=&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>SS</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// We can see the this structure is 4 + 4 + 4 + 8 + 12 = 32 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// There are 3 padding bytes of first t.B expanded to 4 bytes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>(<span style=color:#e6db74>&#34;sizeof(T)&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>t</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// We will see 0 bytes, because it is on stack, so sizeof is the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// proper method to tell how much memory allocated.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>memUsage</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m1</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Even string assignment is in stack.  also is zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>ReadMemStats</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m3</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t2</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;abc&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>ReadMemStats</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m4</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>memUsage</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m3</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m4</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// map will alloc memory in heap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>ReadMemStats</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m5</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t3</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>string</span>{<span style=color:#ae81ff>1</span>: <span style=color:#e6db74>&#34;x&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>ReadMemStats</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m6</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>memUsage</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m5</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m6</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>t2</span>, <span style=color:#a6e22e>t3</span>) <span style=color:#75715e>// prevent compiler error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=golang的chan>golang的chan
<a class=anchor href=#golang%e7%9a%84chan>#</a></h3><ul><li><img src=https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201217212124.png alt=20201217212124></li></ul><blockquote><p>&lsquo;&lsquo;里面的是chan的状态(eg: 一个零值nil通道;一个非零值但已关闭的通道)</p><blockquote><p>&lsquo;空&rsquo;读写阻塞-关闭恐慌;
&lsquo;关闭&rsquo;读为0-关闭写恐慌. 如果是有缓存的chan已关闭，且现在缓存不为空,读正常得到数据</p></blockquote></blockquote><ul><li><p>what:</p><ul><li>通道的主要作用是用来实现并发同步</li><li>可以把一个通道看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此通道发送数据，另外一些协程可以从此通道接收数据。<ul><li>channel类型与值<ul><li>字面形式chan T表示一个元素类型为T的双向通道类型。 编译器允许从此类型的值中接收和向此类型的值中发送数据。</li><li>字面形式chan&lt;- T表示一个元素类型为T的单向发送通道类型。 编译器不允许从此类型的值中接收数据。</li><li>字面形式&lt;-chan T表示一个元素类型为T的单向接收通道类型。 编译器不允许向此类型的值中发送数据。<ul><li><strong>类型T</strong>总是放在最后面。</li></ul></li><li>我们了解到一个通道值可能含有底层部分。 当一个通道值被赋给另一个通道值后，这两个通道值将共享相同的底层部分。</li></ul></li></ul></li></ul></li><li><p>why:</p><ul><li>一个通道内部维护了<strong>三个队列</strong>（均可被视为先进先出队列）：<ul><li>接收数据协程队列（可以看做是先进先出队列但其实并不完全是，见下面解释）。此队列是一个没有长度限制的链表。 此队列中的协程均处于阻塞状态，它们正等待着从此通道接收数据。</li><li>发送数据协程队列（可以看做是先进先出队列但其实并不完全是，见下面解释）。此队列也是一个没有长度限制的链表。 此队列中的协程亦均处于阻塞状态，它们正等待着向此通道发送数据。 此队列中的每个协程将要发送的值（或者此值的指针，取决于具体编译器实现）和此协程一起存储在此队列中。</li><li>数据缓冲队列。这是一个循环队列（绝对先进先出），它的长度为此通道的容量。此队列中存放的值的类型都为此通道的元素类型。 如果此队列中当前存放的值的个数已经达到此通道的容量，则我们说此通道已经处于满槽状态。 如果此队列中当前存放的值的个数为零，则我们说此通道处于空槽状态。 对于一个非缓冲通道（容量为零），它总是同时处于满槽状态和空槽状态。</li></ul></li></ul></li></ul><table><thead><tr><th>操作</th><th>一个零值nil通道</th><th>一个非零值但已关闭的通道</th><th>一个非零值且尚未关闭的通道</th></tr></thead><tbody><tr><td>关闭</td><td><strong>产生恐慌</strong></td><td><strong>产生恐慌</strong></td><td>成功关闭(C)</td></tr><tr><td>发送数据</td><td>永久阻塞(<strong>I</strong>)</td><td><strong>产生恐慌</strong></td><td>阻塞或者成功发送(B)</td></tr><tr><td>接收数据</td><td>永久阻塞(<strong>II</strong>)</td><td>永不阻塞(D)</td><td>阻塞或者成功接收(A)</td></tr></tbody></table><p>看下<strong>I</strong>: 直接看下发送数据的源码
<a href=https://github.com/golang/go/blob/da54dfb6a1f3bef827b9ec3780c98fde77a97d11/src/cmd/compile/internal/gc/walk.go#L1562>walkexpr</a> &ndash;>
<a href=https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L126>chansend1</a> &ndash;>
<a href=https://github.com/golang/go/blob/e35876ec6591768edace6c6f3b12646899fd1b11/src/runtime/chan.go#L147>chansend</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 这里面直接进入睡眠，永远阻塞 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanSendNilChan</span>, <span style=color:#a6e22e>traceEvGoStop</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span></code></pre></div><ul><li>how:<ul><li>五种操作：<ul><li><code>close(ch)</code></li><li><code>ch &lt;- v</code></li><li><code>&lt;-ch</code><ul><li><code>v = &lt;-ch</code></li><li><code>v, sentBeforeClosed = &lt;-ch</code></li></ul></li><li><code>cap(ch)</code></li><li><code>len(ch)</code></li></ul></li></ul></li></ul><h2 id=archive>archive
<a class=anchor href=#archive>#</a></h2><ul><li><p>数据结构</p></li><li><p>常用关键字</p><ul><li>for 和 range</li><li>select</li><li>defer</li><li>panic 和 recover</li><li>make 和 new</li></ul></li><li><p>并发编程</p></li><li><p>内存</p></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=zput/utterances-comments data-repo-id=R_kgDOHhATGQ data-category=Announcements data-category-id=DIC_kwDOHhATGc4CPxca data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#golang基本用法>Golang基本用法</a><ul><li><a href=#数据结构>数据结构</a><ul><li><a href=#string>string</a></li><li><a href=#slice和数组的异同>slice和数组的异同</a></li><li><a href=#map>map</a></li><li><a href=#struct和内存对齐>struct和内存对齐</a></li><li><a href=#chan>chan</a></li><li><a href=#errorunwrap>error.Unwrap</a></li></ul></li><li><a href=#跟类型相关>跟类型相关</a><ul><li><a href=#类型系统>类型系统</a></li><li><a href=#跟函数定义的结构相关>跟函数定义的结构相关</a></li><li><a href=#跟interface相关>跟interface相关</a></li></ul></li><li><a href=#运行时>运行时:</a><ul><li><a href=#并发编程>并发编程</a></li><li><a href=#内存管理>内存管理</a></li></ul></li><li><a href=#附录>附录</a><ul><li><a href=#0方法>0.方法</a></li><li><a href=#1-new-and-make>1. new And make</a></li><li><a href=#2-值类型和引用类型的区别>2. 值类型和引用类型的区别</a></li><li><a href=#3-计算golang中类型的大小的方式>3. 计算golang中类型的大小的方式</a></li><li><a href=#golang的chan>golang的chan</a></li></ul></li><li><a href=#archive>archive</a></li></ul></li></ul></nav></div></aside></main></body></html>